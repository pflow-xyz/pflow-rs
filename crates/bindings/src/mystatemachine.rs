/**

Generated by the following Solidity interface...
```solidity
interface MyStateMachine {
    struct Head {
        uint256[10] latestBlocks;
        uint256 sequence;
        int256[] state;
        Place[] places;
        Transition[] transitions;
    }
    struct Place {
        string label;
        uint8 offset;
        Position position;
        uint256 initial;
        uint256 capacity;
    }
    struct Position {
        uint8 x;
        uint8 y;
    }
    struct Transition {
        string label;
        uint8 offset;
        Position position;
        uint8 role;
        int256[] delta;
        int256[] guard;
    }

    event SignaledEvent(uint8 indexed role, uint8 indexed actionId, uint256 indexed scalar, uint256 sequence);

    function context() external view returns (Head memory);
    function latestBlocks(uint256) external view returns (uint256);
    function sequence() external view returns (uint256);
    function signal(uint8 action, uint256 scalar) external;
    function signalMany(uint8[] memory actions, uint256[] memory scalars) external;
    function state(uint256) external view returns (int256);
}
```

...which was generated by the following JSON ABI:
```json
[
  {
    "type": "function",
    "name": "context",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "tuple",
        "internalType": "struct Model.Head",
        "components": [
          {
            "name": "latestBlocks",
            "type": "uint256[10]",
            "internalType": "uint256[10]"
          },
          {
            "name": "sequence",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "state",
            "type": "int256[]",
            "internalType": "int256[]"
          },
          {
            "name": "places",
            "type": "tuple[]",
            "internalType": "struct Model.Place[]",
            "components": [
              {
                "name": "label",
                "type": "string",
                "internalType": "string"
              },
              {
                "name": "offset",
                "type": "uint8",
                "internalType": "uint8"
              },
              {
                "name": "position",
                "type": "tuple",
                "internalType": "struct Model.Position",
                "components": [
                  {
                    "name": "x",
                    "type": "uint8",
                    "internalType": "uint8"
                  },
                  {
                    "name": "y",
                    "type": "uint8",
                    "internalType": "uint8"
                  }
                ]
              },
              {
                "name": "initial",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "capacity",
                "type": "uint256",
                "internalType": "uint256"
              }
            ]
          },
          {
            "name": "transitions",
            "type": "tuple[]",
            "internalType": "struct Model.Transition[]",
            "components": [
              {
                "name": "label",
                "type": "string",
                "internalType": "string"
              },
              {
                "name": "offset",
                "type": "uint8",
                "internalType": "uint8"
              },
              {
                "name": "position",
                "type": "tuple",
                "internalType": "struct Model.Position",
                "components": [
                  {
                    "name": "x",
                    "type": "uint8",
                    "internalType": "uint8"
                  },
                  {
                    "name": "y",
                    "type": "uint8",
                    "internalType": "uint8"
                  }
                ]
              },
              {
                "name": "role",
                "type": "uint8",
                "internalType": "uint8"
              },
              {
                "name": "delta",
                "type": "int256[]",
                "internalType": "int256[]"
              },
              {
                "name": "guard",
                "type": "int256[]",
                "internalType": "int256[]"
              }
            ]
          }
        ]
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "latestBlocks",
    "inputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "sequence",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "signal",
    "inputs": [
      {
        "name": "action",
        "type": "uint8",
        "internalType": "uint8"
      },
      {
        "name": "scalar",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "signalMany",
    "inputs": [
      {
        "name": "actions",
        "type": "uint8[]",
        "internalType": "uint8[]"
      },
      {
        "name": "scalars",
        "type": "uint256[]",
        "internalType": "uint256[]"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "state",
    "inputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "int256",
        "internalType": "int256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "event",
    "name": "SignaledEvent",
    "inputs": [
      {
        "name": "role",
        "type": "uint8",
        "indexed": true,
        "internalType": "uint8"
      },
      {
        "name": "actionId",
        "type": "uint8",
        "indexed": true,
        "internalType": "uint8"
      },
      {
        "name": "scalar",
        "type": "uint256",
        "indexed": true,
        "internalType": "uint256"
      },
      {
        "name": "sequence",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  }
]
```*/
#[allow(non_camel_case_types, non_snake_case, clippy::style)]
pub mod MyStateMachine {
    use super::*;
    use alloy::sol_types as alloy_sol_types;
    /// The creation / init bytecode of the contract.
    ///
    /// ```text
    ///0x600060028190556101c0604052608081815260a082905260c082905260e08290526101008290526101208290526101408290526101608290526101808290526101a0919091526200005590600390600a620013aa565b506040805160018082528183019092529060208083019080368337505081516200008792600d925060200190620013f2565b503480156200009557600080fd5b5060408051808201825260068152650706c616365360d41b602080830191909152825180840190935260018352600290830152620000d99160009060039062000de2565b50604080518082019091526004815263074786e360e41b60208201526200011a90600160008060408051808201909152600081526001602082015262000efd565b5060408051808201909152600481526374786e3160e01b60208201526200015b90600180600060408051808201909152600281526001602082015262000efd565b506040805180820190915260048152633a3c371960e11b60208201526200019d9060016002600060408051808201909152600081526003602082015262000efd565b5060408051808201909152600481526374786e3360e01b6020820152620001df9060016003600060408051808201909152600281526003602082015262000efd565b50620004bd600180600081548110620001fc57620001fc6200145d565b90600052602060002090600602016040518060c0016040529081600082018054620002279062001473565b80601f0160208091040260200160405190810160405280929190818152602001828054620002559062001473565b8015620002a65780601f106200027a57610100808354040283529160200191620002a6565b820191906000526020600020905b8154815290600101906020018083116200028857829003601f168201915b5050509183525050600182015460ff908116602080840191909152604080518082018252600286015480851682526101009004841681840152818501526003850154909216606084015260048401805483518184028101840190945280845260809094019390918301828280156200033e57602002820191906000526020600020905b81548152602001906001019080831162000329575b50505050508152602001600582018054806020026020016040519081016040528092919081815260200182805480156200039857602002820191906000526020600020905b81548152602001906001019080831162000383575b50505050508152505060008081548110620003b757620003b76200145d565b90600052602060002090600502016040518060a0016040529081600082018054620003e29062001473565b80601f0160208091040260200160405190810160405280929190818152602001828054620004109062001473565b8015620004615780601f10620004355761010080835404028352916020019162000461565b820191906000526020600020905b8154815290600101906020018083116200044357829003601f168201915b5050509183525050600182015460ff908116602080840191909152604080518082018252600286015480851682526101009004909316918301919091528201526003820154606082015260049091015460809091015262001155565b620007a0600360008081548110620004d957620004d96200145d565b90600052602060002090600502016040518060a0016040529081600082018054620005049062001473565b80601f0160208091040260200160405190810160405280929190818152602001828054620005329062001473565b8015620005835780601f10620005575761010080835404028352916020019162000583565b820191906000526020600020905b8154815290600101906020018083116200056557829003601f168201915b505050918352505060018281015460ff9081166020808501919091526040805180820182526002870154808516825261010090049093169183019190915283015260038301546060830152600490920154608090910152805481908110620005ef57620005ef6200145d565b90600052602060002090600602016040518060c00160405290816000820180546200061a9062001473565b80601f0160208091040260200160405190810160405280929190818152602001828054620006489062001473565b8015620006995780601f106200066d5761010080835404028352916020019162000699565b820191906000526020600020905b8154815290600101906020018083116200067b57829003601f168201915b5050509183525050600182015460ff908116602080840191909152604080518082018252600286015480851682526101009004841681840152818501526003850154909216606084015260048401805483518184028101840190945280845260809094019390918301828280156200073157602002820191906000526020600020905b8154815260200190600101908083116200071c575b50505050508152602001600582018054806020026020016040519081016040528092919081815260200182805480156200078b57602002820191906000526020600020905b81548152602001906001019080831162000776575b505050505081525050620011f160201b60201c565b62000a7e60036001600281548110620007bd57620007bd6200145d565b90600052602060002090600602016040518060c0016040529081600082018054620007e89062001473565b80601f0160208091040260200160405190810160405280929190818152602001828054620008169062001473565b8015620008675780601f106200083b5761010080835404028352916020019162000867565b820191906000526020600020905b8154815290600101906020018083116200084957829003601f168201915b5050509183525050600182015460ff90811660208084019190915260408051808201825260028601548085168252610100900484168184015281850152600385015490921660608401526004840180548351818402810184019094528084526080909401939091830182828015620008ff57602002820191906000526020600020905b815481526020019060010190808311620008ea575b50505050508152602001600582018054806020026020016040519081016040528092919081815260200182805480156200095957602002820191906000526020600020905b81548152602001906001019080831162000944575b505050505081525050600080815481106200097857620009786200145d565b90600052602060002090600502016040518060a0016040529081600082018054620009a39062001473565b80601f0160208091040260200160405190810160405280929190818152602001828054620009d19062001473565b801562000a225780601f10620009f65761010080835404028352916020019162000a22565b820191906000526020600020905b81548152906001019060200180831162000a0457829003601f168201915b5050509183525050600182015460ff908116602080840191909152604080518082018252600286015480851682526101009004909316918301919091528201526003820154606082015260049091015460809091015262001288565b62000d6660016000808154811062000a9a5762000a9a6200145d565b90600052602060002090600502016040518060a001604052908160008201805462000ac59062001473565b80601f016020809104026020016040519081016040528092919081815260200182805462000af39062001473565b801562000b445780601f1062000b185761010080835404028352916020019162000b44565b820191906000526020600020905b81548152906001019060200180831162000b2657829003601f168201915b505050918352505060018281015460ff9081166020808501919091526040805180820182526002870154808516825261010090049093169183019190915283015260038084015460608401526004909301546080909201919091528054909190811062000bb55762000bb56200145d565b90600052602060002090600602016040518060c001604052908160008201805462000be09062001473565b80601f016020809104026020016040519081016040528092919081815260200182805462000c0e9062001473565b801562000c5f5780601f1062000c335761010080835404028352916020019162000c5f565b820191906000526020600020905b81548152906001019060200180831162000c4157829003601f168201915b5050509183525050600182015460ff9081166020808401919091526040805180820182526002860154808516825261010090048416818401528185015260038501549092166060840152600484018054835181840281018401909452808452608090940193909183018282801562000cf757602002820191906000526020600020905b81548152602001906001019080831162000ce2575b505050505081526020016005820180548060200260200160405190810160405280929190818152602001828054801562000d5157602002820191906000526020600020905b81548152602001906001019080831162000d3c575b5050505050815250506200131360201b60201c565b60005b600160ff8216101562000ddb5760008160ff168154811062000d8f5762000d8f6200145d565b906000526020600020906005020160030154600d8260ff168154811062000dba5762000dba6200145d565b6000918252602090912001558062000dd281620014c5565b91505062000d69565b5062001630565b62000e286040805160a081018252606081526000602080830182905283518085018552828152908101919091529091820190815260200160008152602001600081525090565b6040805160a0810182528681526000805460ff811660208401529282018590526060820187905260808201869052600183018155805280519091829160059091027f290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e5630190819062000e9a90826200153a565b5060208281015160018301805460ff92831660ff1990911617905560408401518051600285018054929094015183166101000261ffff19909216921691909117179055606082015160038201556080909101516004909101559050949350505050565b62000f486040805160c0810182526060815260006020808301829052835180850185528281529081019190915290918201908152600060208201526060604082018190529081015290565b60015460ff85811691161462000fa55760405162461bcd60e51b815260206004820152601c60248201527f7472616e73616374696f6e203d3e20656e756d206d69736d617463680000000060448201526064015b60405180910390fd5b60006040518060c001604052808881526020018660ff1681526020018481526020018560ff1681526020018760ff166001600160401b0381111562000fee5762000fee62001447565b60405190808252806020026020018201604052801562001018578160200160208202803683370190505b5081526020018760ff166001600160401b038111156200103c576200103c62001447565b60405190808252806020026020018201604052801562001066578160200160208202803683370190505b5090526001805480820182556000919091528151919250829160069091027fb10e2d527612073b26eecdfd717e6a320cf44b4afac2b0732d9fcbe2b7fa0cf601908190620010b590826200153a565b5060208281015160018301805460ff92831660ff1991821617909155604085015180516002860180549286015185166101000261ffff1990931691851691909117919091179055606085015160038501805491909316911617905560808301518051620011299260048501920190620013f2565b5060a0820151805162001147916005840191602090910190620013f2565b509198975050505050505050565b60008313620011965760405162461bcd60e51b81526020600482015260126024820152600080516020620027d0833981519152604482015260640162000f9c565b826001836020015160ff1681548110620011b457620011b46200145d565b9060005260206000209060060201600401826020015160ff1681548110620011e057620011e06200145d565b600091825260209091200155505050565b60008313620012325760405162461bcd60e51b81526020600482015260126024820152600080516020620027d0833981519152604482015260640162000f9c565b6200123f83600062001606565b6001826020015160ff16815481106200125c576200125c6200145d565b9060005260206000209060060201600401836020015160ff1681548110620011e057620011e06200145d565b60008313620012c95760405162461bcd60e51b81526020600482015260126024820152600080516020620027d0833981519152604482015260640162000f9c565b826001836020015160ff1681548110620012e757620012e76200145d565b9060005260206000209060060201600501826020015160ff1681548110620011e057620011e06200145d565b60008313620013545760405162461bcd60e51b81526020600482015260126024820152600080516020620027d0833981519152604482015260640162000f9c565b6200136183600062001606565b6001826020015160ff16815481106200137e576200137e6200145d565b9060005260206000209060060201600501836020015160ff1681548110620011e057620011e06200145d565b82600a8101928215620013e0579160200282015b82811115620013e0578251829060ff16905591602001919060010190620013be565b50620013ee92915062001430565b5090565b828054828255906000526020600020908101928215620013e0579160200282015b82811115620013e057825182559160200191906001019062001413565b5b80821115620013ee576000815560010162001431565b634e487b7160e01b600052604160045260246000fd5b634e487b7160e01b600052603260045260246000fd5b600181811c908216806200148857607f821691505b602082108103620014a957634e487b7160e01b600052602260045260246000fd5b50919050565b634e487b7160e01b600052601160045260246000fd5b600060ff821660ff8103620014de57620014de620014af565b60010192915050565b601f8211156200153557600081815260208120601f850160051c81016020861015620015105750805b601f850160051c820191505b8181101562001531578281556001016200151c565b5050505b505050565b81516001600160401b0381111562001556576200155662001447565b6200156e8162001567845462001473565b84620014e7565b602080601f831160018114620015a657600084156200158d5750858301515b600019600386901b1c1916600185901b17855562001531565b600085815260208120601f198616915b82811015620015d757888601518255948401946001909101908401620015b6565b5085821015620015f65787850151600019600388901b60f8161c191681555b5050505050600190811b01905550565b8181036000831280158383131683831282161715620016295762001629620014af565b5092915050565b61119080620016406000396000f3fe608060405234801561001057600080fd5b50600436106100625760003560e01c80633e4f49e614610067578063529d15cc1461008d5780636ee376e614610096578063d0496d6a146100a9578063ddc3b187146100be578063fff01fe2146100d3575b600080fd5b61007a610075366004610c44565b6100e6565b6040519081526020015b60405180910390f35b61007a60025481565b61007a6100a4366004610c44565b610107565b6100b161011e565b6040516100849190610e4f565b6100d16100cc366004610f04565b6104dc565b005b6100d16100e1366004610f7a565b6104f3565b600d81815481106100f657600080fd5b600091825260209091200154905081565b600381600a811061011757600080fd5b0154905081565b610126610bf0565b604080516101e081019091528060a081016003600a8282826020028201915b81548152602001906001019080831161014557505050505081526020016002548152602001600d8054806020026020016040519081016040528092919081815260200182805480156101b657602002820191906000526020600020905b8154815260200190600101908083116101a2575b505050505081526020016000805480602002602001604051908101604052809291908181526020016000905b828210156102f457838290600052602060002090600502016040518060a001604052908160008201805461021590610fe6565b80601f016020809104026020016040519081016040528092919081815260200182805461024190610fe6565b801561028e5780601f106102635761010080835404028352916020019161028e565b820191906000526020600020905b81548152906001019060200180831161027157829003601f168201915b505050918352505060018281015460ff9081166020808501919091526040805180820182526002870154808516825261010090049093168383015284019190915260038401546060840152600490930154608090920191909152918352920191016101e2565b5050505081526020016001805480602002602001604051908101604052809291908181526020016000905b828210156104d157838290600052602060002090600602016040518060c001604052908160008201805461035290610fe6565b80601f016020809104026020016040519081016040528092919081815260200182805461037e90610fe6565b80156103cb5780601f106103a0576101008083540402835291602001916103cb565b820191906000526020600020905b8154815290600101906020018083116103ae57829003601f168201915b5050509183525050600182015460ff9081166020808401919091526040805180820182526002860154808516825261010090048416818401528185015260038501549092166060840152600484018054835181840281018401909452808452608090940193909183018282801561046157602002820191906000526020600020905b81548152602001906001019080831161044d575b50505050508152602001600582018054806020026020016040519081016040528092919081815260200182805480156104b957602002820191906000526020600020905b8154815260200190600101908083116104a5575b5050505050815250508152602001906001019061031f565b505050915250919050565b6104e682826105bc565b6104ef4361085e565b5050565b8281146105475760405162461bcd60e51b815260206004820152601c60248201527f4d6f64656c52656769737472793a20696e76616c696420696e7075740000000060448201526064015b60405180910390fd5b60005b838110156105ac5761059a85858381811061056757610567611020565b905060200201602081019061057c9190611036565b84848481811061058e5761058e611020565b905060200201356105bc565b806105a48161106e565b91505061054a565b506105b64361085e565b50505050565b600060018360ff16815481106105d4576105d4611020565b90600052602060002090600602016040518060c00160405290816000820180546105fd90610fe6565b80601f016020809104026020016040519081016040528092919081815260200182805461062990610fe6565b80156106765780601f1061064b57610100808354040283529160200191610676565b820191906000526020600020905b81548152906001019060200180831161065957829003601f168201915b5050509183525050600182015460ff9081166020808401919091526040805180820182526002860154808516825261010090048416818401528185015260038501549092166060840152600484018054835181840281018401909452808452608090940193909183018282801561070c57602002820191906000526020600020905b8154815260200190600101908083116106f8575b505050505081526020016005820180548060200260200160405190810160405280929190818152602001828054801561076457602002820191906000526020600020905b815481526020019060010190808311610750575b5050505050815250509050610778816108bf565b156107b15760405162461bcd60e51b81526020600482015260096024820152681a5b9a1a589a5d195960ba1b604482015260640161053e565b806020015160ff168360ff16146107ca576107ca611087565b60005b60005460ff90811690821610156107fb576107e98183856109f9565b806107f38161109d565b9150506107cd565b506002805490600061080c8361106e565b9190505550818360ff16826060015160ff167f50e4a52b0772bed9f06a7d3f7dfa66d73640067a5cc77a73c24556ccc900fa0860025460405161085191815260200190565b60405180910390a4505050565b60005b60098160ff1610156108b957600361087a8260016110bc565b60ff16600a811061088d5761088d611020565b015460038260ff16600a81106108a5576108a5611020565b0155806108b18161109d565b915050610861565b50600c55565b6000805b600160ff821610156109f0578260a001518160ff16815181106108e8576108e8611020565b60200260200101516000146109de5760008360a001518260ff168151811061091257610912611020565b602002602001015112156109815760008360a001518260ff168151811061093b5761093b611020565b6020026020010151600d8360ff168154811061095957610959611020565b906000526020600020015461096e91906110db565b1261097c5750600192915050565b6109de565b60008360a001518260ff168151811061099c5761099c611020565b6020026020010151600d8360ff16815481106109ba576109ba611020565b90600052602060002001546109cf9190611103565b12156109de5750600192915050565b806109e88161109d565b9150506108c3565b50600092915050565b60008111610a3a5760405162461bcd60e51b815260206004820152600e60248201526d34b73b30b634b21039b1b0b630b960911b604482015260640161053e565b81608001518360ff1681518110610a5357610a53611020565b6020026020010151600014610beb578082608001518460ff1681518110610a7c57610a7c611020565b6020026020010151610a8e919061112a565b600d8460ff1681548110610aa457610aa4611020565b9060005260206000200154610ab991906110db565b600d8460ff1681548110610acf57610acf611020565b90600052602060002001819055506000600d8460ff1681548110610af557610af5611020565b90600052602060002001541215610b3a5760405162461bcd60e51b8152602060048201526009602482015268756e646572666c6f7760b81b604482015260640161053e565b6000808460ff1681548110610b5157610b51611020565b9060005260206000209060050201600401541115610beb5760008360ff1681548110610b7f57610b7f611020565b906000526020600020906005020160040154600d8460ff1681548110610ba757610ba7611020565b90600052602060002001541315610beb5760405162461bcd60e51b81526020600482015260086024820152676f766572666c6f7760c01b604482015260640161053e565b505050565b6040518060a00160405280610c03610c25565b8152602001600081526020016060815260200160608152602001606081525090565b604051806101400160405280600a906020820280368337509192915050565b600060208284031215610c5657600080fd5b5035919050565b600081518084526020808501945080840160005b83811015610c8d57815187529582019590820190600101610c71565b509495945050505050565b6000815180845260005b81811015610cbe57602081850181015186830182015201610ca2565b506000602082860101526020601f19601f83011685010191505092915050565b600081518084526020808501808196508360051b8101915082860160005b85811015610d7b578284038952815160c08151818752610d1e82880182610c98565b91505060ff878301511687870152604080830151610d4e82890182805160ff908116835260209182015116910152565b505060608201516080878101919091529091015160a0909501949094529784019790840190600101610cfc565b5091979650505050505050565b600081518084526020808501808196508360051b8101915082860160005b85811015610d7b578284038952815160e08151818752610dc882880182610c98565b8389015160ff908116898b015260408086015180518316828c01526020810151831660608c015292945092509050606084015191506080818316818a0152808501519250505060a087830381890152610e218383610c5d565b93015187840360c0890152929150610e3b90508183610c5d565b9a87019a9550505090840190600101610da6565b6020808252825160009190828483015b600a821015610e7e578251815291830191600191909101908301610e5f565b50505083015161016083015260408301516101c06101808401819052610ea86101e0850183610c5d565b91506060850151601f1980868503016101a0870152610ec78483610cde565b93506080870151915080868503018387015250610ee48382610d88565b9695505050505050565b803560ff81168114610eff57600080fd5b919050565b60008060408385031215610f1757600080fd5b610f2083610eee565b946020939093013593505050565b60008083601f840112610f4057600080fd5b50813567ffffffffffffffff811115610f5857600080fd5b6020830191508360208260051b8501011115610f7357600080fd5b9250929050565b60008060008060408587031215610f9057600080fd5b843567ffffffffffffffff80821115610fa857600080fd5b610fb488838901610f2e565b90965094506020870135915080821115610fcd57600080fd5b50610fda87828801610f2e565b95989497509550505050565b600181811c90821680610ffa57607f821691505b60208210810361101a57634e487b7160e01b600052602260045260246000fd5b50919050565b634e487b7160e01b600052603260045260246000fd5b60006020828403121561104857600080fd5b61105182610eee565b9392505050565b634e487b7160e01b600052601160045260246000fd5b60006001820161108057611080611058565b5060010190565b634e487b7160e01b600052600160045260246000fd5b600060ff821660ff81036110b3576110b3611058565b60010192915050565b60ff81811683821601908111156110d5576110d5611058565b92915050565b80820182811260008312801582168215821617156110fb576110fb611058565b505092915050565b818103600083128015838313168383128216171561112357611123611058565b5092915050565b80820260008212600160ff1b8414161561114657611146611058565b81810583148215176110d5576110d561105856fea264697066735822122043ba8b6950a9cd68d9683da7a0084f28f874764923f90dd4f7cf017d084d479464736f6c63430008150033776569676874206d757374206265203e20300000000000000000000000000000
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\0`\x02\x81\x90Ua\x01\xC0`@R`\x80\x81\x81R`\xA0\x82\x90R`\xC0\x82\x90R`\xE0\x82\x90Ra\x01\0\x82\x90Ra\x01 \x82\x90Ra\x01@\x82\x90Ra\x01`\x82\x90Ra\x01\x80\x82\x90Ra\x01\xA0\x91\x90\x91Rb\0\0U\x90`\x03\x90`\nb\0\x13\xAAV[P`@\x80Q`\x01\x80\x82R\x81\x83\x01\x90\x92R\x90` \x80\x83\x01\x90\x806\x837PP\x81Qb\0\0\x87\x92`\r\x92P` \x01\x90b\0\x13\xF2V[P4\x80\x15b\0\0\x95W`\0\x80\xFD[P`@\x80Q\x80\x82\x01\x82R`\x06\x81Re\x07\x06\xC6\x166S`\xD4\x1B` \x80\x83\x01\x91\x90\x91R\x82Q\x80\x84\x01\x90\x93R`\x01\x83R`\x02\x90\x83\x01Rb\0\0\xD9\x91`\0\x90`\x03\x90b\0\r\xE2V[P`@\x80Q\x80\x82\x01\x90\x91R`\x04\x81Rc\x07G\x86\xE3`\xE4\x1B` \x82\x01Rb\0\x01\x1A\x90`\x01`\0\x80`@\x80Q\x80\x82\x01\x90\x91R`\0\x81R`\x01` \x82\x01Rb\0\x0E\xFDV[P`@\x80Q\x80\x82\x01\x90\x91R`\x04\x81Rctxn1`\xE0\x1B` \x82\x01Rb\0\x01[\x90`\x01\x80`\0`@\x80Q\x80\x82\x01\x90\x91R`\x02\x81R`\x01` \x82\x01Rb\0\x0E\xFDV[P`@\x80Q\x80\x82\x01\x90\x91R`\x04\x81Rc:<7\x19`\xE1\x1B` \x82\x01Rb\0\x01\x9D\x90`\x01`\x02`\0`@\x80Q\x80\x82\x01\x90\x91R`\0\x81R`\x03` \x82\x01Rb\0\x0E\xFDV[P`@\x80Q\x80\x82\x01\x90\x91R`\x04\x81Rctxn3`\xE0\x1B` \x82\x01Rb\0\x01\xDF\x90`\x01`\x03`\0`@\x80Q\x80\x82\x01\x90\x91R`\x02\x81R`\x03` \x82\x01Rb\0\x0E\xFDV[Pb\0\x04\xBD`\x01\x80`\0\x81T\x81\x10b\0\x01\xFCWb\0\x01\xFCb\0\x14]V[\x90`\0R` `\0 \x90`\x06\x02\x01`@Q\x80`\xC0\x01`@R\x90\x81`\0\x82\x01\x80Tb\0\x02'\x90b\0\x14sV[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Tb\0\x02U\x90b\0\x14sV[\x80\x15b\0\x02\xA6W\x80`\x1F\x10b\0\x02zWa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91b\0\x02\xA6V[\x82\x01\x91\x90`\0R` `\0 \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11b\0\x02\x88W\x82\x90\x03`\x1F\x16\x82\x01\x91[PPP\x91\x83RPP`\x01\x82\x01T`\xFF\x90\x81\x16` \x80\x84\x01\x91\x90\x91R`@\x80Q\x80\x82\x01\x82R`\x02\x86\x01T\x80\x85\x16\x82Ra\x01\0\x90\x04\x84\x16\x81\x84\x01R\x81\x85\x01R`\x03\x85\x01T\x90\x92\x16``\x84\x01R`\x04\x84\x01\x80T\x83Q\x81\x84\x02\x81\x01\x84\x01\x90\x94R\x80\x84R`\x80\x90\x94\x01\x93\x90\x91\x83\x01\x82\x82\x80\x15b\0\x03>W` \x02\x82\x01\x91\x90`\0R` `\0 \x90[\x81T\x81R` \x01\x90`\x01\x01\x90\x80\x83\x11b\0\x03)W[PPPPP\x81R` \x01`\x05\x82\x01\x80T\x80` \x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80T\x80\x15b\0\x03\x98W` \x02\x82\x01\x91\x90`\0R` `\0 \x90[\x81T\x81R` \x01\x90`\x01\x01\x90\x80\x83\x11b\0\x03\x83W[PPPPP\x81RPP`\0\x80\x81T\x81\x10b\0\x03\xB7Wb\0\x03\xB7b\0\x14]V[\x90`\0R` `\0 \x90`\x05\x02\x01`@Q\x80`\xA0\x01`@R\x90\x81`\0\x82\x01\x80Tb\0\x03\xE2\x90b\0\x14sV[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Tb\0\x04\x10\x90b\0\x14sV[\x80\x15b\0\x04aW\x80`\x1F\x10b\0\x045Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91b\0\x04aV[\x82\x01\x91\x90`\0R` `\0 \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11b\0\x04CW\x82\x90\x03`\x1F\x16\x82\x01\x91[PPP\x91\x83RPP`\x01\x82\x01T`\xFF\x90\x81\x16` \x80\x84\x01\x91\x90\x91R`@\x80Q\x80\x82\x01\x82R`\x02\x86\x01T\x80\x85\x16\x82Ra\x01\0\x90\x04\x90\x93\x16\x91\x83\x01\x91\x90\x91R\x82\x01R`\x03\x82\x01T``\x82\x01R`\x04\x90\x91\x01T`\x80\x90\x91\x01Rb\0\x11UV[b\0\x07\xA0`\x03`\0\x80\x81T\x81\x10b\0\x04\xD9Wb\0\x04\xD9b\0\x14]V[\x90`\0R` `\0 \x90`\x05\x02\x01`@Q\x80`\xA0\x01`@R\x90\x81`\0\x82\x01\x80Tb\0\x05\x04\x90b\0\x14sV[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Tb\0\x052\x90b\0\x14sV[\x80\x15b\0\x05\x83W\x80`\x1F\x10b\0\x05WWa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91b\0\x05\x83V[\x82\x01\x91\x90`\0R` `\0 \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11b\0\x05eW\x82\x90\x03`\x1F\x16\x82\x01\x91[PPP\x91\x83RPP`\x01\x82\x81\x01T`\xFF\x90\x81\x16` \x80\x85\x01\x91\x90\x91R`@\x80Q\x80\x82\x01\x82R`\x02\x87\x01T\x80\x85\x16\x82Ra\x01\0\x90\x04\x90\x93\x16\x91\x83\x01\x91\x90\x91R\x83\x01R`\x03\x83\x01T``\x83\x01R`\x04\x90\x92\x01T`\x80\x90\x91\x01R\x80T\x81\x90\x81\x10b\0\x05\xEFWb\0\x05\xEFb\0\x14]V[\x90`\0R` `\0 \x90`\x06\x02\x01`@Q\x80`\xC0\x01`@R\x90\x81`\0\x82\x01\x80Tb\0\x06\x1A\x90b\0\x14sV[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Tb\0\x06H\x90b\0\x14sV[\x80\x15b\0\x06\x99W\x80`\x1F\x10b\0\x06mWa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91b\0\x06\x99V[\x82\x01\x91\x90`\0R` `\0 \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11b\0\x06{W\x82\x90\x03`\x1F\x16\x82\x01\x91[PPP\x91\x83RPP`\x01\x82\x01T`\xFF\x90\x81\x16` \x80\x84\x01\x91\x90\x91R`@\x80Q\x80\x82\x01\x82R`\x02\x86\x01T\x80\x85\x16\x82Ra\x01\0\x90\x04\x84\x16\x81\x84\x01R\x81\x85\x01R`\x03\x85\x01T\x90\x92\x16``\x84\x01R`\x04\x84\x01\x80T\x83Q\x81\x84\x02\x81\x01\x84\x01\x90\x94R\x80\x84R`\x80\x90\x94\x01\x93\x90\x91\x83\x01\x82\x82\x80\x15b\0\x071W` \x02\x82\x01\x91\x90`\0R` `\0 \x90[\x81T\x81R` \x01\x90`\x01\x01\x90\x80\x83\x11b\0\x07\x1CW[PPPPP\x81R` \x01`\x05\x82\x01\x80T\x80` \x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80T\x80\x15b\0\x07\x8BW` \x02\x82\x01\x91\x90`\0R` `\0 \x90[\x81T\x81R` \x01\x90`\x01\x01\x90\x80\x83\x11b\0\x07vW[PPPPP\x81RPPb\0\x11\xF1` \x1B` \x1CV[b\0\n~`\x03`\x01`\x02\x81T\x81\x10b\0\x07\xBDWb\0\x07\xBDb\0\x14]V[\x90`\0R` `\0 \x90`\x06\x02\x01`@Q\x80`\xC0\x01`@R\x90\x81`\0\x82\x01\x80Tb\0\x07\xE8\x90b\0\x14sV[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Tb\0\x08\x16\x90b\0\x14sV[\x80\x15b\0\x08gW\x80`\x1F\x10b\0\x08;Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91b\0\x08gV[\x82\x01\x91\x90`\0R` `\0 \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11b\0\x08IW\x82\x90\x03`\x1F\x16\x82\x01\x91[PPP\x91\x83RPP`\x01\x82\x01T`\xFF\x90\x81\x16` \x80\x84\x01\x91\x90\x91R`@\x80Q\x80\x82\x01\x82R`\x02\x86\x01T\x80\x85\x16\x82Ra\x01\0\x90\x04\x84\x16\x81\x84\x01R\x81\x85\x01R`\x03\x85\x01T\x90\x92\x16``\x84\x01R`\x04\x84\x01\x80T\x83Q\x81\x84\x02\x81\x01\x84\x01\x90\x94R\x80\x84R`\x80\x90\x94\x01\x93\x90\x91\x83\x01\x82\x82\x80\x15b\0\x08\xFFW` \x02\x82\x01\x91\x90`\0R` `\0 \x90[\x81T\x81R` \x01\x90`\x01\x01\x90\x80\x83\x11b\0\x08\xEAW[PPPPP\x81R` \x01`\x05\x82\x01\x80T\x80` \x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80T\x80\x15b\0\tYW` \x02\x82\x01\x91\x90`\0R` `\0 \x90[\x81T\x81R` \x01\x90`\x01\x01\x90\x80\x83\x11b\0\tDW[PPPPP\x81RPP`\0\x80\x81T\x81\x10b\0\txWb\0\txb\0\x14]V[\x90`\0R` `\0 \x90`\x05\x02\x01`@Q\x80`\xA0\x01`@R\x90\x81`\0\x82\x01\x80Tb\0\t\xA3\x90b\0\x14sV[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Tb\0\t\xD1\x90b\0\x14sV[\x80\x15b\0\n\"W\x80`\x1F\x10b\0\t\xF6Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91b\0\n\"V[\x82\x01\x91\x90`\0R` `\0 \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11b\0\n\x04W\x82\x90\x03`\x1F\x16\x82\x01\x91[PPP\x91\x83RPP`\x01\x82\x01T`\xFF\x90\x81\x16` \x80\x84\x01\x91\x90\x91R`@\x80Q\x80\x82\x01\x82R`\x02\x86\x01T\x80\x85\x16\x82Ra\x01\0\x90\x04\x90\x93\x16\x91\x83\x01\x91\x90\x91R\x82\x01R`\x03\x82\x01T``\x82\x01R`\x04\x90\x91\x01T`\x80\x90\x91\x01Rb\0\x12\x88V[b\0\rf`\x01`\0\x80\x81T\x81\x10b\0\n\x9AWb\0\n\x9Ab\0\x14]V[\x90`\0R` `\0 \x90`\x05\x02\x01`@Q\x80`\xA0\x01`@R\x90\x81`\0\x82\x01\x80Tb\0\n\xC5\x90b\0\x14sV[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Tb\0\n\xF3\x90b\0\x14sV[\x80\x15b\0\x0BDW\x80`\x1F\x10b\0\x0B\x18Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91b\0\x0BDV[\x82\x01\x91\x90`\0R` `\0 \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11b\0\x0B&W\x82\x90\x03`\x1F\x16\x82\x01\x91[PPP\x91\x83RPP`\x01\x82\x81\x01T`\xFF\x90\x81\x16` \x80\x85\x01\x91\x90\x91R`@\x80Q\x80\x82\x01\x82R`\x02\x87\x01T\x80\x85\x16\x82Ra\x01\0\x90\x04\x90\x93\x16\x91\x83\x01\x91\x90\x91R\x83\x01R`\x03\x80\x84\x01T``\x84\x01R`\x04\x90\x93\x01T`\x80\x90\x92\x01\x91\x90\x91R\x80T\x90\x91\x90\x81\x10b\0\x0B\xB5Wb\0\x0B\xB5b\0\x14]V[\x90`\0R` `\0 \x90`\x06\x02\x01`@Q\x80`\xC0\x01`@R\x90\x81`\0\x82\x01\x80Tb\0\x0B\xE0\x90b\0\x14sV[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Tb\0\x0C\x0E\x90b\0\x14sV[\x80\x15b\0\x0C_W\x80`\x1F\x10b\0\x0C3Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91b\0\x0C_V[\x82\x01\x91\x90`\0R` `\0 \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11b\0\x0CAW\x82\x90\x03`\x1F\x16\x82\x01\x91[PPP\x91\x83RPP`\x01\x82\x01T`\xFF\x90\x81\x16` \x80\x84\x01\x91\x90\x91R`@\x80Q\x80\x82\x01\x82R`\x02\x86\x01T\x80\x85\x16\x82Ra\x01\0\x90\x04\x84\x16\x81\x84\x01R\x81\x85\x01R`\x03\x85\x01T\x90\x92\x16``\x84\x01R`\x04\x84\x01\x80T\x83Q\x81\x84\x02\x81\x01\x84\x01\x90\x94R\x80\x84R`\x80\x90\x94\x01\x93\x90\x91\x83\x01\x82\x82\x80\x15b\0\x0C\xF7W` \x02\x82\x01\x91\x90`\0R` `\0 \x90[\x81T\x81R` \x01\x90`\x01\x01\x90\x80\x83\x11b\0\x0C\xE2W[PPPPP\x81R` \x01`\x05\x82\x01\x80T\x80` \x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80T\x80\x15b\0\rQW` \x02\x82\x01\x91\x90`\0R` `\0 \x90[\x81T\x81R` \x01\x90`\x01\x01\x90\x80\x83\x11b\0\r<W[PPPPP\x81RPPb\0\x13\x13` \x1B` \x1CV[`\0[`\x01`\xFF\x82\x16\x10\x15b\0\r\xDBW`\0\x81`\xFF\x16\x81T\x81\x10b\0\r\x8FWb\0\r\x8Fb\0\x14]V[\x90`\0R` `\0 \x90`\x05\x02\x01`\x03\x01T`\r\x82`\xFF\x16\x81T\x81\x10b\0\r\xBAWb\0\r\xBAb\0\x14]V[`\0\x91\x82R` \x90\x91 \x01U\x80b\0\r\xD2\x81b\0\x14\xC5V[\x91PPb\0\riV[Pb\0\x160V[b\0\x0E(`@\x80Q`\xA0\x81\x01\x82R``\x81R`\0` \x80\x83\x01\x82\x90R\x83Q\x80\x85\x01\x85R\x82\x81R\x90\x81\x01\x91\x90\x91R\x90\x91\x82\x01\x90\x81R` \x01`\0\x81R` \x01`\0\x81RP\x90V[`@\x80Q`\xA0\x81\x01\x82R\x86\x81R`\0\x80T`\xFF\x81\x16` \x84\x01R\x92\x82\x01\x85\x90R``\x82\x01\x87\x90R`\x80\x82\x01\x86\x90R`\x01\x83\x01\x81U\x80R\x80Q\x90\x91\x82\x91`\x05\x90\x91\x02\x7F)\r\xEC\xD9T\x8Bb\xA8\xD6\x03E\xA9\x888o\xC8K\xA6\xBC\x95H@\x08\xF66/\x93\x16\x0E\xF3\xE5c\x01\x90\x81\x90b\0\x0E\x9A\x90\x82b\0\x15:V[P` \x82\x81\x01Q`\x01\x83\x01\x80T`\xFF\x92\x83\x16`\xFF\x19\x90\x91\x16\x17\x90U`@\x84\x01Q\x80Q`\x02\x85\x01\x80T\x92\x90\x94\x01Q\x83\x16a\x01\0\x02a\xFF\xFF\x19\x90\x92\x16\x92\x16\x91\x90\x91\x17\x17\x90U``\x82\x01Q`\x03\x82\x01U`\x80\x90\x91\x01Q`\x04\x90\x91\x01U\x90P\x94\x93PPPPV[b\0\x0FH`@\x80Q`\xC0\x81\x01\x82R``\x81R`\0` \x80\x83\x01\x82\x90R\x83Q\x80\x85\x01\x85R\x82\x81R\x90\x81\x01\x91\x90\x91R\x90\x91\x82\x01\x90\x81R`\0` \x82\x01R```@\x82\x01\x81\x90R\x90\x81\x01R\x90V[`\x01T`\xFF\x85\x81\x16\x91\x16\x14b\0\x0F\xA5W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1C`$\x82\x01R\x7Ftransaction => enum mismatch\0\0\0\0`D\x82\x01R`d\x01[`@Q\x80\x91\x03\x90\xFD[`\0`@Q\x80`\xC0\x01`@R\x80\x88\x81R` \x01\x86`\xFF\x16\x81R` \x01\x84\x81R` \x01\x85`\xFF\x16\x81R` \x01\x87`\xFF\x16`\x01`\x01`@\x1B\x03\x81\x11\x15b\0\x0F\xEEWb\0\x0F\xEEb\0\x14GV[`@Q\x90\x80\x82R\x80` \x02` \x01\x82\x01`@R\x80\x15b\0\x10\x18W\x81` \x01` \x82\x02\x806\x837\x01\x90P[P\x81R` \x01\x87`\xFF\x16`\x01`\x01`@\x1B\x03\x81\x11\x15b\0\x10<Wb\0\x10<b\0\x14GV[`@Q\x90\x80\x82R\x80` \x02` \x01\x82\x01`@R\x80\x15b\0\x10fW\x81` \x01` \x82\x02\x806\x837\x01\x90P[P\x90R`\x01\x80T\x80\x82\x01\x82U`\0\x91\x90\x91R\x81Q\x91\x92P\x82\x91`\x06\x90\x91\x02\x7F\xB1\x0E-Rv\x12\x07;&\xEE\xCD\xFDq~j2\x0C\xF4KJ\xFA\xC2\xB0s-\x9F\xCB\xE2\xB7\xFA\x0C\xF6\x01\x90\x81\x90b\0\x10\xB5\x90\x82b\0\x15:V[P` \x82\x81\x01Q`\x01\x83\x01\x80T`\xFF\x92\x83\x16`\xFF\x19\x91\x82\x16\x17\x90\x91U`@\x85\x01Q\x80Q`\x02\x86\x01\x80T\x92\x86\x01Q\x85\x16a\x01\0\x02a\xFF\xFF\x19\x90\x93\x16\x91\x85\x16\x91\x90\x91\x17\x91\x90\x91\x17\x90U``\x85\x01Q`\x03\x85\x01\x80T\x91\x90\x93\x16\x91\x16\x17\x90U`\x80\x83\x01Q\x80Qb\0\x11)\x92`\x04\x85\x01\x92\x01\x90b\0\x13\xF2V[P`\xA0\x82\x01Q\x80Qb\0\x11G\x91`\x05\x84\x01\x91` \x90\x91\x01\x90b\0\x13\xF2V[P\x91\x98\x97PPPPPPPPV[`\0\x83\x13b\0\x11\x96W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x12`$\x82\x01R`\0\x80Q` b\0'\xD0\x839\x81Q\x91R`D\x82\x01R`d\x01b\0\x0F\x9CV[\x82`\x01\x83` \x01Q`\xFF\x16\x81T\x81\x10b\0\x11\xB4Wb\0\x11\xB4b\0\x14]V[\x90`\0R` `\0 \x90`\x06\x02\x01`\x04\x01\x82` \x01Q`\xFF\x16\x81T\x81\x10b\0\x11\xE0Wb\0\x11\xE0b\0\x14]V[`\0\x91\x82R` \x90\x91 \x01UPPPV[`\0\x83\x13b\0\x122W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x12`$\x82\x01R`\0\x80Q` b\0'\xD0\x839\x81Q\x91R`D\x82\x01R`d\x01b\0\x0F\x9CV[b\0\x12?\x83`\0b\0\x16\x06V[`\x01\x82` \x01Q`\xFF\x16\x81T\x81\x10b\0\x12\\Wb\0\x12\\b\0\x14]V[\x90`\0R` `\0 \x90`\x06\x02\x01`\x04\x01\x83` \x01Q`\xFF\x16\x81T\x81\x10b\0\x11\xE0Wb\0\x11\xE0b\0\x14]V[`\0\x83\x13b\0\x12\xC9W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x12`$\x82\x01R`\0\x80Q` b\0'\xD0\x839\x81Q\x91R`D\x82\x01R`d\x01b\0\x0F\x9CV[\x82`\x01\x83` \x01Q`\xFF\x16\x81T\x81\x10b\0\x12\xE7Wb\0\x12\xE7b\0\x14]V[\x90`\0R` `\0 \x90`\x06\x02\x01`\x05\x01\x82` \x01Q`\xFF\x16\x81T\x81\x10b\0\x11\xE0Wb\0\x11\xE0b\0\x14]V[`\0\x83\x13b\0\x13TW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x12`$\x82\x01R`\0\x80Q` b\0'\xD0\x839\x81Q\x91R`D\x82\x01R`d\x01b\0\x0F\x9CV[b\0\x13a\x83`\0b\0\x16\x06V[`\x01\x82` \x01Q`\xFF\x16\x81T\x81\x10b\0\x13~Wb\0\x13~b\0\x14]V[\x90`\0R` `\0 \x90`\x06\x02\x01`\x05\x01\x83` \x01Q`\xFF\x16\x81T\x81\x10b\0\x11\xE0Wb\0\x11\xE0b\0\x14]V[\x82`\n\x81\x01\x92\x82\x15b\0\x13\xE0W\x91` \x02\x82\x01[\x82\x81\x11\x15b\0\x13\xE0W\x82Q\x82\x90`\xFF\x16\x90U\x91` \x01\x91\x90`\x01\x01\x90b\0\x13\xBEV[Pb\0\x13\xEE\x92\x91Pb\0\x140V[P\x90V[\x82\x80T\x82\x82U\x90`\0R` `\0 \x90\x81\x01\x92\x82\x15b\0\x13\xE0W\x91` \x02\x82\x01[\x82\x81\x11\x15b\0\x13\xE0W\x82Q\x82U\x91` \x01\x91\x90`\x01\x01\x90b\0\x14\x13V[[\x80\x82\x11\x15b\0\x13\xEEW`\0\x81U`\x01\x01b\0\x141V[cNH{q`\xE0\x1B`\0R`A`\x04R`$`\0\xFD[cNH{q`\xE0\x1B`\0R`2`\x04R`$`\0\xFD[`\x01\x81\x81\x1C\x90\x82\x16\x80b\0\x14\x88W`\x7F\x82\x16\x91P[` \x82\x10\x81\x03b\0\x14\xA9WcNH{q`\xE0\x1B`\0R`\"`\x04R`$`\0\xFD[P\x91\x90PV[cNH{q`\xE0\x1B`\0R`\x11`\x04R`$`\0\xFD[`\0`\xFF\x82\x16`\xFF\x81\x03b\0\x14\xDEWb\0\x14\xDEb\0\x14\xAFV[`\x01\x01\x92\x91PPV[`\x1F\x82\x11\x15b\0\x155W`\0\x81\x81R` \x81 `\x1F\x85\x01`\x05\x1C\x81\x01` \x86\x10\x15b\0\x15\x10WP\x80[`\x1F\x85\x01`\x05\x1C\x82\x01\x91P[\x81\x81\x10\x15b\0\x151W\x82\x81U`\x01\x01b\0\x15\x1CV[PPP[PPPV[\x81Q`\x01`\x01`@\x1B\x03\x81\x11\x15b\0\x15VWb\0\x15Vb\0\x14GV[b\0\x15n\x81b\0\x15g\x84Tb\0\x14sV[\x84b\0\x14\xE7V[` \x80`\x1F\x83\x11`\x01\x81\x14b\0\x15\xA6W`\0\x84\x15b\0\x15\x8DWP\x85\x83\x01Q[`\0\x19`\x03\x86\x90\x1B\x1C\x19\x16`\x01\x85\x90\x1B\x17\x85Ub\0\x151V[`\0\x85\x81R` \x81 `\x1F\x19\x86\x16\x91[\x82\x81\x10\x15b\0\x15\xD7W\x88\x86\x01Q\x82U\x94\x84\x01\x94`\x01\x90\x91\x01\x90\x84\x01b\0\x15\xB6V[P\x85\x82\x10\x15b\0\x15\xF6W\x87\x85\x01Q`\0\x19`\x03\x88\x90\x1B`\xF8\x16\x1C\x19\x16\x81U[PPPPP`\x01\x90\x81\x1B\x01\x90UPV[\x81\x81\x03`\0\x83\x12\x80\x15\x83\x83\x13\x16\x83\x83\x12\x82\x16\x17\x15b\0\x16)Wb\0\x16)b\0\x14\xAFV[P\x92\x91PPV[a\x11\x90\x80b\0\x16@`\09`\0\xF3\xFE`\x80`@R4\x80\x15a\0\x10W`\0\x80\xFD[P`\x046\x10a\0bW`\x005`\xE0\x1C\x80c>OI\xE6\x14a\0gW\x80cR\x9D\x15\xCC\x14a\0\x8DW\x80cn\xE3v\xE6\x14a\0\x96W\x80c\xD0Imj\x14a\0\xA9W\x80c\xDD\xC3\xB1\x87\x14a\0\xBEW\x80c\xFF\xF0\x1F\xE2\x14a\0\xD3W[`\0\x80\xFD[a\0za\0u6`\x04a\x0CDV[a\0\xE6V[`@Q\x90\x81R` \x01[`@Q\x80\x91\x03\x90\xF3[a\0z`\x02T\x81V[a\0za\0\xA46`\x04a\x0CDV[a\x01\x07V[a\0\xB1a\x01\x1EV[`@Qa\0\x84\x91\x90a\x0EOV[a\0\xD1a\0\xCC6`\x04a\x0F\x04V[a\x04\xDCV[\0[a\0\xD1a\0\xE16`\x04a\x0FzV[a\x04\xF3V[`\r\x81\x81T\x81\x10a\0\xF6W`\0\x80\xFD[`\0\x91\x82R` \x90\x91 \x01T\x90P\x81V[`\x03\x81`\n\x81\x10a\x01\x17W`\0\x80\xFD[\x01T\x90P\x81V[a\x01&a\x0B\xF0V[`@\x80Qa\x01\xE0\x81\x01\x90\x91R\x80`\xA0\x81\x01`\x03`\n\x82\x82\x82` \x02\x82\x01\x91[\x81T\x81R` \x01\x90`\x01\x01\x90\x80\x83\x11a\x01EWPPPPP\x81R` \x01`\x02T\x81R` \x01`\r\x80T\x80` \x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80T\x80\x15a\x01\xB6W` \x02\x82\x01\x91\x90`\0R` `\0 \x90[\x81T\x81R` \x01\x90`\x01\x01\x90\x80\x83\x11a\x01\xA2W[PPPPP\x81R` \x01`\0\x80T\x80` \x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01`\0\x90[\x82\x82\x10\x15a\x02\xF4W\x83\x82\x90`\0R` `\0 \x90`\x05\x02\x01`@Q\x80`\xA0\x01`@R\x90\x81`\0\x82\x01\x80Ta\x02\x15\x90a\x0F\xE6V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x02A\x90a\x0F\xE6V[\x80\x15a\x02\x8EW\x80`\x1F\x10a\x02cWa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x02\x8EV[\x82\x01\x91\x90`\0R` `\0 \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x02qW\x82\x90\x03`\x1F\x16\x82\x01\x91[PPP\x91\x83RPP`\x01\x82\x81\x01T`\xFF\x90\x81\x16` \x80\x85\x01\x91\x90\x91R`@\x80Q\x80\x82\x01\x82R`\x02\x87\x01T\x80\x85\x16\x82Ra\x01\0\x90\x04\x90\x93\x16\x83\x83\x01R\x84\x01\x91\x90\x91R`\x03\x84\x01T``\x84\x01R`\x04\x90\x93\x01T`\x80\x90\x92\x01\x91\x90\x91R\x91\x83R\x92\x01\x91\x01a\x01\xE2V[PPPP\x81R` \x01`\x01\x80T\x80` \x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01`\0\x90[\x82\x82\x10\x15a\x04\xD1W\x83\x82\x90`\0R` `\0 \x90`\x06\x02\x01`@Q\x80`\xC0\x01`@R\x90\x81`\0\x82\x01\x80Ta\x03R\x90a\x0F\xE6V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x03~\x90a\x0F\xE6V[\x80\x15a\x03\xCBW\x80`\x1F\x10a\x03\xA0Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x03\xCBV[\x82\x01\x91\x90`\0R` `\0 \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x03\xAEW\x82\x90\x03`\x1F\x16\x82\x01\x91[PPP\x91\x83RPP`\x01\x82\x01T`\xFF\x90\x81\x16` \x80\x84\x01\x91\x90\x91R`@\x80Q\x80\x82\x01\x82R`\x02\x86\x01T\x80\x85\x16\x82Ra\x01\0\x90\x04\x84\x16\x81\x84\x01R\x81\x85\x01R`\x03\x85\x01T\x90\x92\x16``\x84\x01R`\x04\x84\x01\x80T\x83Q\x81\x84\x02\x81\x01\x84\x01\x90\x94R\x80\x84R`\x80\x90\x94\x01\x93\x90\x91\x83\x01\x82\x82\x80\x15a\x04aW` \x02\x82\x01\x91\x90`\0R` `\0 \x90[\x81T\x81R` \x01\x90`\x01\x01\x90\x80\x83\x11a\x04MW[PPPPP\x81R` \x01`\x05\x82\x01\x80T\x80` \x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80T\x80\x15a\x04\xB9W` \x02\x82\x01\x91\x90`\0R` `\0 \x90[\x81T\x81R` \x01\x90`\x01\x01\x90\x80\x83\x11a\x04\xA5W[PPPPP\x81RPP\x81R` \x01\x90`\x01\x01\x90a\x03\x1FV[PPP\x91RP\x91\x90PV[a\x04\xE6\x82\x82a\x05\xBCV[a\x04\xEFCa\x08^V[PPV[\x82\x81\x14a\x05GW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1C`$\x82\x01R\x7FModelRegistry: invalid input\0\0\0\0`D\x82\x01R`d\x01[`@Q\x80\x91\x03\x90\xFD[`\0[\x83\x81\x10\x15a\x05\xACWa\x05\x9A\x85\x85\x83\x81\x81\x10a\x05gWa\x05ga\x10 V[\x90P` \x02\x01` \x81\x01\x90a\x05|\x91\x90a\x106V[\x84\x84\x84\x81\x81\x10a\x05\x8EWa\x05\x8Ea\x10 V[\x90P` \x02\x015a\x05\xBCV[\x80a\x05\xA4\x81a\x10nV[\x91PPa\x05JV[Pa\x05\xB6Ca\x08^V[PPPPV[`\0`\x01\x83`\xFF\x16\x81T\x81\x10a\x05\xD4Wa\x05\xD4a\x10 V[\x90`\0R` `\0 \x90`\x06\x02\x01`@Q\x80`\xC0\x01`@R\x90\x81`\0\x82\x01\x80Ta\x05\xFD\x90a\x0F\xE6V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x06)\x90a\x0F\xE6V[\x80\x15a\x06vW\x80`\x1F\x10a\x06KWa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x06vV[\x82\x01\x91\x90`\0R` `\0 \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x06YW\x82\x90\x03`\x1F\x16\x82\x01\x91[PPP\x91\x83RPP`\x01\x82\x01T`\xFF\x90\x81\x16` \x80\x84\x01\x91\x90\x91R`@\x80Q\x80\x82\x01\x82R`\x02\x86\x01T\x80\x85\x16\x82Ra\x01\0\x90\x04\x84\x16\x81\x84\x01R\x81\x85\x01R`\x03\x85\x01T\x90\x92\x16``\x84\x01R`\x04\x84\x01\x80T\x83Q\x81\x84\x02\x81\x01\x84\x01\x90\x94R\x80\x84R`\x80\x90\x94\x01\x93\x90\x91\x83\x01\x82\x82\x80\x15a\x07\x0CW` \x02\x82\x01\x91\x90`\0R` `\0 \x90[\x81T\x81R` \x01\x90`\x01\x01\x90\x80\x83\x11a\x06\xF8W[PPPPP\x81R` \x01`\x05\x82\x01\x80T\x80` \x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80T\x80\x15a\x07dW` \x02\x82\x01\x91\x90`\0R` `\0 \x90[\x81T\x81R` \x01\x90`\x01\x01\x90\x80\x83\x11a\x07PW[PPPPP\x81RPP\x90Pa\x07x\x81a\x08\xBFV[\x15a\x07\xB1W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\t`$\x82\x01Rh\x1A[\x9A\x1AX\x9A]\x19Y`\xBA\x1B`D\x82\x01R`d\x01a\x05>V[\x80` \x01Q`\xFF\x16\x83`\xFF\x16\x14a\x07\xCAWa\x07\xCAa\x10\x87V[`\0[`\0T`\xFF\x90\x81\x16\x90\x82\x16\x10\x15a\x07\xFBWa\x07\xE9\x81\x83\x85a\t\xF9V[\x80a\x07\xF3\x81a\x10\x9DV[\x91PPa\x07\xCDV[P`\x02\x80T\x90`\0a\x08\x0C\x83a\x10nV[\x91\x90PUP\x81\x83`\xFF\x16\x82``\x01Q`\xFF\x16\x7FP\xE4\xA5+\x07r\xBE\xD9\xF0j}?}\xFAf\xD76@\x06z\\\xC7zs\xC2EV\xCC\xC9\0\xFA\x08`\x02T`@Qa\x08Q\x91\x81R` \x01\x90V[`@Q\x80\x91\x03\x90\xA4PPPV[`\0[`\t\x81`\xFF\x16\x10\x15a\x08\xB9W`\x03a\x08z\x82`\x01a\x10\xBCV[`\xFF\x16`\n\x81\x10a\x08\x8DWa\x08\x8Da\x10 V[\x01T`\x03\x82`\xFF\x16`\n\x81\x10a\x08\xA5Wa\x08\xA5a\x10 V[\x01U\x80a\x08\xB1\x81a\x10\x9DV[\x91PPa\x08aV[P`\x0CUV[`\0\x80[`\x01`\xFF\x82\x16\x10\x15a\t\xF0W\x82`\xA0\x01Q\x81`\xFF\x16\x81Q\x81\x10a\x08\xE8Wa\x08\xE8a\x10 V[` \x02` \x01\x01Q`\0\x14a\t\xDEW`\0\x83`\xA0\x01Q\x82`\xFF\x16\x81Q\x81\x10a\t\x12Wa\t\x12a\x10 V[` \x02` \x01\x01Q\x12\x15a\t\x81W`\0\x83`\xA0\x01Q\x82`\xFF\x16\x81Q\x81\x10a\t;Wa\t;a\x10 V[` \x02` \x01\x01Q`\r\x83`\xFF\x16\x81T\x81\x10a\tYWa\tYa\x10 V[\x90`\0R` `\0 \x01Ta\tn\x91\x90a\x10\xDBV[\x12a\t|WP`\x01\x92\x91PPV[a\t\xDEV[`\0\x83`\xA0\x01Q\x82`\xFF\x16\x81Q\x81\x10a\t\x9CWa\t\x9Ca\x10 V[` \x02` \x01\x01Q`\r\x83`\xFF\x16\x81T\x81\x10a\t\xBAWa\t\xBAa\x10 V[\x90`\0R` `\0 \x01Ta\t\xCF\x91\x90a\x11\x03V[\x12\x15a\t\xDEWP`\x01\x92\x91PPV[\x80a\t\xE8\x81a\x10\x9DV[\x91PPa\x08\xC3V[P`\0\x92\x91PPV[`\0\x81\x11a\n:W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x0E`$\x82\x01Rm4\xB7;0\xB64\xB2\x109\xB1\xB0\xB60\xB9`\x91\x1B`D\x82\x01R`d\x01a\x05>V[\x81`\x80\x01Q\x83`\xFF\x16\x81Q\x81\x10a\nSWa\nSa\x10 V[` \x02` \x01\x01Q`\0\x14a\x0B\xEBW\x80\x82`\x80\x01Q\x84`\xFF\x16\x81Q\x81\x10a\n|Wa\n|a\x10 V[` \x02` \x01\x01Qa\n\x8E\x91\x90a\x11*V[`\r\x84`\xFF\x16\x81T\x81\x10a\n\xA4Wa\n\xA4a\x10 V[\x90`\0R` `\0 \x01Ta\n\xB9\x91\x90a\x10\xDBV[`\r\x84`\xFF\x16\x81T\x81\x10a\n\xCFWa\n\xCFa\x10 V[\x90`\0R` `\0 \x01\x81\x90UP`\0`\r\x84`\xFF\x16\x81T\x81\x10a\n\xF5Wa\n\xF5a\x10 V[\x90`\0R` `\0 \x01T\x12\x15a\x0B:W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\t`$\x82\x01Rhunderflow`\xB8\x1B`D\x82\x01R`d\x01a\x05>V[`\0\x80\x84`\xFF\x16\x81T\x81\x10a\x0BQWa\x0BQa\x10 V[\x90`\0R` `\0 \x90`\x05\x02\x01`\x04\x01T\x11\x15a\x0B\xEBW`\0\x83`\xFF\x16\x81T\x81\x10a\x0B\x7FWa\x0B\x7Fa\x10 V[\x90`\0R` `\0 \x90`\x05\x02\x01`\x04\x01T`\r\x84`\xFF\x16\x81T\x81\x10a\x0B\xA7Wa\x0B\xA7a\x10 V[\x90`\0R` `\0 \x01T\x13\x15a\x0B\xEBW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x08`$\x82\x01Rgoverflow`\xC0\x1B`D\x82\x01R`d\x01a\x05>V[PPPV[`@Q\x80`\xA0\x01`@R\x80a\x0C\x03a\x0C%V[\x81R` \x01`\0\x81R` \x01``\x81R` \x01``\x81R` \x01``\x81RP\x90V[`@Q\x80a\x01@\x01`@R\x80`\n\x90` \x82\x02\x806\x837P\x91\x92\x91PPV[`\0` \x82\x84\x03\x12\x15a\x0CVW`\0\x80\xFD[P5\x91\x90PV[`\0\x81Q\x80\x84R` \x80\x85\x01\x94P\x80\x84\x01`\0[\x83\x81\x10\x15a\x0C\x8DW\x81Q\x87R\x95\x82\x01\x95\x90\x82\x01\x90`\x01\x01a\x0CqV[P\x94\x95\x94PPPPPV[`\0\x81Q\x80\x84R`\0[\x81\x81\x10\x15a\x0C\xBEW` \x81\x85\x01\x81\x01Q\x86\x83\x01\x82\x01R\x01a\x0C\xA2V[P`\0` \x82\x86\x01\x01R` `\x1F\x19`\x1F\x83\x01\x16\x85\x01\x01\x91PP\x92\x91PPV[`\0\x81Q\x80\x84R` \x80\x85\x01\x80\x81\x96P\x83`\x05\x1B\x81\x01\x91P\x82\x86\x01`\0[\x85\x81\x10\x15a\r{W\x82\x84\x03\x89R\x81Q`\xC0\x81Q\x81\x87Ra\r\x1E\x82\x88\x01\x82a\x0C\x98V[\x91PP`\xFF\x87\x83\x01Q\x16\x87\x87\x01R`@\x80\x83\x01Qa\rN\x82\x89\x01\x82\x80Q`\xFF\x90\x81\x16\x83R` \x91\x82\x01Q\x16\x91\x01RV[PP``\x82\x01Q`\x80\x87\x81\x01\x91\x90\x91R\x90\x91\x01Q`\xA0\x90\x95\x01\x94\x90\x94R\x97\x84\x01\x97\x90\x84\x01\x90`\x01\x01a\x0C\xFCV[P\x91\x97\x96PPPPPPPV[`\0\x81Q\x80\x84R` \x80\x85\x01\x80\x81\x96P\x83`\x05\x1B\x81\x01\x91P\x82\x86\x01`\0[\x85\x81\x10\x15a\r{W\x82\x84\x03\x89R\x81Q`\xE0\x81Q\x81\x87Ra\r\xC8\x82\x88\x01\x82a\x0C\x98V[\x83\x89\x01Q`\xFF\x90\x81\x16\x89\x8B\x01R`@\x80\x86\x01Q\x80Q\x83\x16\x82\x8C\x01R` \x81\x01Q\x83\x16``\x8C\x01R\x92\x94P\x92P\x90P``\x84\x01Q\x91P`\x80\x81\x83\x16\x81\x8A\x01R\x80\x85\x01Q\x92PPP`\xA0\x87\x83\x03\x81\x89\x01Ra\x0E!\x83\x83a\x0C]V[\x93\x01Q\x87\x84\x03`\xC0\x89\x01R\x92\x91Pa\x0E;\x90P\x81\x83a\x0C]V[\x9A\x87\x01\x9A\x95PPP\x90\x84\x01\x90`\x01\x01a\r\xA6V[` \x80\x82R\x82Q`\0\x91\x90\x82\x84\x83\x01[`\n\x82\x10\x15a\x0E~W\x82Q\x81R\x91\x83\x01\x91`\x01\x91\x90\x91\x01\x90\x83\x01a\x0E_V[PPP\x83\x01Qa\x01`\x83\x01R`@\x83\x01Qa\x01\xC0a\x01\x80\x84\x01\x81\x90Ra\x0E\xA8a\x01\xE0\x85\x01\x83a\x0C]V[\x91P``\x85\x01Q`\x1F\x19\x80\x86\x85\x03\x01a\x01\xA0\x87\x01Ra\x0E\xC7\x84\x83a\x0C\xDEV[\x93P`\x80\x87\x01Q\x91P\x80\x86\x85\x03\x01\x83\x87\x01RPa\x0E\xE4\x83\x82a\r\x88V[\x96\x95PPPPPPV[\x805`\xFF\x81\x16\x81\x14a\x0E\xFFW`\0\x80\xFD[\x91\x90PV[`\0\x80`@\x83\x85\x03\x12\x15a\x0F\x17W`\0\x80\xFD[a\x0F \x83a\x0E\xEEV[\x94` \x93\x90\x93\x015\x93PPPV[`\0\x80\x83`\x1F\x84\x01\x12a\x0F@W`\0\x80\xFD[P\x815g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x0FXW`\0\x80\xFD[` \x83\x01\x91P\x83` \x82`\x05\x1B\x85\x01\x01\x11\x15a\x0FsW`\0\x80\xFD[\x92P\x92\x90PV[`\0\x80`\0\x80`@\x85\x87\x03\x12\x15a\x0F\x90W`\0\x80\xFD[\x845g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x80\x82\x11\x15a\x0F\xA8W`\0\x80\xFD[a\x0F\xB4\x88\x83\x89\x01a\x0F.V[\x90\x96P\x94P` \x87\x015\x91P\x80\x82\x11\x15a\x0F\xCDW`\0\x80\xFD[Pa\x0F\xDA\x87\x82\x88\x01a\x0F.V[\x95\x98\x94\x97P\x95PPPPV[`\x01\x81\x81\x1C\x90\x82\x16\x80a\x0F\xFAW`\x7F\x82\x16\x91P[` \x82\x10\x81\x03a\x10\x1AWcNH{q`\xE0\x1B`\0R`\"`\x04R`$`\0\xFD[P\x91\x90PV[cNH{q`\xE0\x1B`\0R`2`\x04R`$`\0\xFD[`\0` \x82\x84\x03\x12\x15a\x10HW`\0\x80\xFD[a\x10Q\x82a\x0E\xEEV[\x93\x92PPPV[cNH{q`\xE0\x1B`\0R`\x11`\x04R`$`\0\xFD[`\0`\x01\x82\x01a\x10\x80Wa\x10\x80a\x10XV[P`\x01\x01\x90V[cNH{q`\xE0\x1B`\0R`\x01`\x04R`$`\0\xFD[`\0`\xFF\x82\x16`\xFF\x81\x03a\x10\xB3Wa\x10\xB3a\x10XV[`\x01\x01\x92\x91PPV[`\xFF\x81\x81\x16\x83\x82\x16\x01\x90\x81\x11\x15a\x10\xD5Wa\x10\xD5a\x10XV[\x92\x91PPV[\x80\x82\x01\x82\x81\x12`\0\x83\x12\x80\x15\x82\x16\x82\x15\x82\x16\x17\x15a\x10\xFBWa\x10\xFBa\x10XV[PP\x92\x91PPV[\x81\x81\x03`\0\x83\x12\x80\x15\x83\x83\x13\x16\x83\x83\x12\x82\x16\x17\x15a\x11#Wa\x11#a\x10XV[P\x92\x91PPV[\x80\x82\x02`\0\x82\x12`\x01`\xFF\x1B\x84\x14\x16\x15a\x11FWa\x11Fa\x10XV[\x81\x81\x05\x83\x14\x82\x15\x17a\x10\xD5Wa\x10\xD5a\x10XV\xFE\xA2dipfsX\"\x12 C\xBA\x8BiP\xA9\xCDh\xD9h=\xA7\xA0\x08O(\xF8tvI#\xF9\r\xD4\xF7\xCF\x01}\x08MG\x94dsolcC\0\x08\x15\x003weight must be > 0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
    );
    /// The runtime bytecode of the contract, as deployed on the network.
    ///
    /// ```text
    ///0x608060405234801561001057600080fd5b50600436106100625760003560e01c80633e4f49e614610067578063529d15cc1461008d5780636ee376e614610096578063d0496d6a146100a9578063ddc3b187146100be578063fff01fe2146100d3575b600080fd5b61007a610075366004610c44565b6100e6565b6040519081526020015b60405180910390f35b61007a60025481565b61007a6100a4366004610c44565b610107565b6100b161011e565b6040516100849190610e4f565b6100d16100cc366004610f04565b6104dc565b005b6100d16100e1366004610f7a565b6104f3565b600d81815481106100f657600080fd5b600091825260209091200154905081565b600381600a811061011757600080fd5b0154905081565b610126610bf0565b604080516101e081019091528060a081016003600a8282826020028201915b81548152602001906001019080831161014557505050505081526020016002548152602001600d8054806020026020016040519081016040528092919081815260200182805480156101b657602002820191906000526020600020905b8154815260200190600101908083116101a2575b505050505081526020016000805480602002602001604051908101604052809291908181526020016000905b828210156102f457838290600052602060002090600502016040518060a001604052908160008201805461021590610fe6565b80601f016020809104026020016040519081016040528092919081815260200182805461024190610fe6565b801561028e5780601f106102635761010080835404028352916020019161028e565b820191906000526020600020905b81548152906001019060200180831161027157829003601f168201915b505050918352505060018281015460ff9081166020808501919091526040805180820182526002870154808516825261010090049093168383015284019190915260038401546060840152600490930154608090920191909152918352920191016101e2565b5050505081526020016001805480602002602001604051908101604052809291908181526020016000905b828210156104d157838290600052602060002090600602016040518060c001604052908160008201805461035290610fe6565b80601f016020809104026020016040519081016040528092919081815260200182805461037e90610fe6565b80156103cb5780601f106103a0576101008083540402835291602001916103cb565b820191906000526020600020905b8154815290600101906020018083116103ae57829003601f168201915b5050509183525050600182015460ff9081166020808401919091526040805180820182526002860154808516825261010090048416818401528185015260038501549092166060840152600484018054835181840281018401909452808452608090940193909183018282801561046157602002820191906000526020600020905b81548152602001906001019080831161044d575b50505050508152602001600582018054806020026020016040519081016040528092919081815260200182805480156104b957602002820191906000526020600020905b8154815260200190600101908083116104a5575b5050505050815250508152602001906001019061031f565b505050915250919050565b6104e682826105bc565b6104ef4361085e565b5050565b8281146105475760405162461bcd60e51b815260206004820152601c60248201527f4d6f64656c52656769737472793a20696e76616c696420696e7075740000000060448201526064015b60405180910390fd5b60005b838110156105ac5761059a85858381811061056757610567611020565b905060200201602081019061057c9190611036565b84848481811061058e5761058e611020565b905060200201356105bc565b806105a48161106e565b91505061054a565b506105b64361085e565b50505050565b600060018360ff16815481106105d4576105d4611020565b90600052602060002090600602016040518060c00160405290816000820180546105fd90610fe6565b80601f016020809104026020016040519081016040528092919081815260200182805461062990610fe6565b80156106765780601f1061064b57610100808354040283529160200191610676565b820191906000526020600020905b81548152906001019060200180831161065957829003601f168201915b5050509183525050600182015460ff9081166020808401919091526040805180820182526002860154808516825261010090048416818401528185015260038501549092166060840152600484018054835181840281018401909452808452608090940193909183018282801561070c57602002820191906000526020600020905b8154815260200190600101908083116106f8575b505050505081526020016005820180548060200260200160405190810160405280929190818152602001828054801561076457602002820191906000526020600020905b815481526020019060010190808311610750575b5050505050815250509050610778816108bf565b156107b15760405162461bcd60e51b81526020600482015260096024820152681a5b9a1a589a5d195960ba1b604482015260640161053e565b806020015160ff168360ff16146107ca576107ca611087565b60005b60005460ff90811690821610156107fb576107e98183856109f9565b806107f38161109d565b9150506107cd565b506002805490600061080c8361106e565b9190505550818360ff16826060015160ff167f50e4a52b0772bed9f06a7d3f7dfa66d73640067a5cc77a73c24556ccc900fa0860025460405161085191815260200190565b60405180910390a4505050565b60005b60098160ff1610156108b957600361087a8260016110bc565b60ff16600a811061088d5761088d611020565b015460038260ff16600a81106108a5576108a5611020565b0155806108b18161109d565b915050610861565b50600c55565b6000805b600160ff821610156109f0578260a001518160ff16815181106108e8576108e8611020565b60200260200101516000146109de5760008360a001518260ff168151811061091257610912611020565b602002602001015112156109815760008360a001518260ff168151811061093b5761093b611020565b6020026020010151600d8360ff168154811061095957610959611020565b906000526020600020015461096e91906110db565b1261097c5750600192915050565b6109de565b60008360a001518260ff168151811061099c5761099c611020565b6020026020010151600d8360ff16815481106109ba576109ba611020565b90600052602060002001546109cf9190611103565b12156109de5750600192915050565b806109e88161109d565b9150506108c3565b50600092915050565b60008111610a3a5760405162461bcd60e51b815260206004820152600e60248201526d34b73b30b634b21039b1b0b630b960911b604482015260640161053e565b81608001518360ff1681518110610a5357610a53611020565b6020026020010151600014610beb578082608001518460ff1681518110610a7c57610a7c611020565b6020026020010151610a8e919061112a565b600d8460ff1681548110610aa457610aa4611020565b9060005260206000200154610ab991906110db565b600d8460ff1681548110610acf57610acf611020565b90600052602060002001819055506000600d8460ff1681548110610af557610af5611020565b90600052602060002001541215610b3a5760405162461bcd60e51b8152602060048201526009602482015268756e646572666c6f7760b81b604482015260640161053e565b6000808460ff1681548110610b5157610b51611020565b9060005260206000209060050201600401541115610beb5760008360ff1681548110610b7f57610b7f611020565b906000526020600020906005020160040154600d8460ff1681548110610ba757610ba7611020565b90600052602060002001541315610beb5760405162461bcd60e51b81526020600482015260086024820152676f766572666c6f7760c01b604482015260640161053e565b505050565b6040518060a00160405280610c03610c25565b8152602001600081526020016060815260200160608152602001606081525090565b604051806101400160405280600a906020820280368337509192915050565b600060208284031215610c5657600080fd5b5035919050565b600081518084526020808501945080840160005b83811015610c8d57815187529582019590820190600101610c71565b509495945050505050565b6000815180845260005b81811015610cbe57602081850181015186830182015201610ca2565b506000602082860101526020601f19601f83011685010191505092915050565b600081518084526020808501808196508360051b8101915082860160005b85811015610d7b578284038952815160c08151818752610d1e82880182610c98565b91505060ff878301511687870152604080830151610d4e82890182805160ff908116835260209182015116910152565b505060608201516080878101919091529091015160a0909501949094529784019790840190600101610cfc565b5091979650505050505050565b600081518084526020808501808196508360051b8101915082860160005b85811015610d7b578284038952815160e08151818752610dc882880182610c98565b8389015160ff908116898b015260408086015180518316828c01526020810151831660608c015292945092509050606084015191506080818316818a0152808501519250505060a087830381890152610e218383610c5d565b93015187840360c0890152929150610e3b90508183610c5d565b9a87019a9550505090840190600101610da6565b6020808252825160009190828483015b600a821015610e7e578251815291830191600191909101908301610e5f565b50505083015161016083015260408301516101c06101808401819052610ea86101e0850183610c5d565b91506060850151601f1980868503016101a0870152610ec78483610cde565b93506080870151915080868503018387015250610ee48382610d88565b9695505050505050565b803560ff81168114610eff57600080fd5b919050565b60008060408385031215610f1757600080fd5b610f2083610eee565b946020939093013593505050565b60008083601f840112610f4057600080fd5b50813567ffffffffffffffff811115610f5857600080fd5b6020830191508360208260051b8501011115610f7357600080fd5b9250929050565b60008060008060408587031215610f9057600080fd5b843567ffffffffffffffff80821115610fa857600080fd5b610fb488838901610f2e565b90965094506020870135915080821115610fcd57600080fd5b50610fda87828801610f2e565b95989497509550505050565b600181811c90821680610ffa57607f821691505b60208210810361101a57634e487b7160e01b600052602260045260246000fd5b50919050565b634e487b7160e01b600052603260045260246000fd5b60006020828403121561104857600080fd5b61105182610eee565b9392505050565b634e487b7160e01b600052601160045260246000fd5b60006001820161108057611080611058565b5060010190565b634e487b7160e01b600052600160045260246000fd5b600060ff821660ff81036110b3576110b3611058565b60010192915050565b60ff81811683821601908111156110d5576110d5611058565b92915050565b80820182811260008312801582168215821617156110fb576110fb611058565b505092915050565b818103600083128015838313168383128216171561112357611123611058565b5092915050565b80820260008212600160ff1b8414161561114657611146611058565b81810583148215176110d5576110d561105856fea264697066735822122043ba8b6950a9cd68d9683da7a0084f28f874764923f90dd4f7cf017d084d479464736f6c63430008150033
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static DEPLOYED_BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R4\x80\x15a\0\x10W`\0\x80\xFD[P`\x046\x10a\0bW`\x005`\xE0\x1C\x80c>OI\xE6\x14a\0gW\x80cR\x9D\x15\xCC\x14a\0\x8DW\x80cn\xE3v\xE6\x14a\0\x96W\x80c\xD0Imj\x14a\0\xA9W\x80c\xDD\xC3\xB1\x87\x14a\0\xBEW\x80c\xFF\xF0\x1F\xE2\x14a\0\xD3W[`\0\x80\xFD[a\0za\0u6`\x04a\x0CDV[a\0\xE6V[`@Q\x90\x81R` \x01[`@Q\x80\x91\x03\x90\xF3[a\0z`\x02T\x81V[a\0za\0\xA46`\x04a\x0CDV[a\x01\x07V[a\0\xB1a\x01\x1EV[`@Qa\0\x84\x91\x90a\x0EOV[a\0\xD1a\0\xCC6`\x04a\x0F\x04V[a\x04\xDCV[\0[a\0\xD1a\0\xE16`\x04a\x0FzV[a\x04\xF3V[`\r\x81\x81T\x81\x10a\0\xF6W`\0\x80\xFD[`\0\x91\x82R` \x90\x91 \x01T\x90P\x81V[`\x03\x81`\n\x81\x10a\x01\x17W`\0\x80\xFD[\x01T\x90P\x81V[a\x01&a\x0B\xF0V[`@\x80Qa\x01\xE0\x81\x01\x90\x91R\x80`\xA0\x81\x01`\x03`\n\x82\x82\x82` \x02\x82\x01\x91[\x81T\x81R` \x01\x90`\x01\x01\x90\x80\x83\x11a\x01EWPPPPP\x81R` \x01`\x02T\x81R` \x01`\r\x80T\x80` \x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80T\x80\x15a\x01\xB6W` \x02\x82\x01\x91\x90`\0R` `\0 \x90[\x81T\x81R` \x01\x90`\x01\x01\x90\x80\x83\x11a\x01\xA2W[PPPPP\x81R` \x01`\0\x80T\x80` \x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01`\0\x90[\x82\x82\x10\x15a\x02\xF4W\x83\x82\x90`\0R` `\0 \x90`\x05\x02\x01`@Q\x80`\xA0\x01`@R\x90\x81`\0\x82\x01\x80Ta\x02\x15\x90a\x0F\xE6V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x02A\x90a\x0F\xE6V[\x80\x15a\x02\x8EW\x80`\x1F\x10a\x02cWa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x02\x8EV[\x82\x01\x91\x90`\0R` `\0 \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x02qW\x82\x90\x03`\x1F\x16\x82\x01\x91[PPP\x91\x83RPP`\x01\x82\x81\x01T`\xFF\x90\x81\x16` \x80\x85\x01\x91\x90\x91R`@\x80Q\x80\x82\x01\x82R`\x02\x87\x01T\x80\x85\x16\x82Ra\x01\0\x90\x04\x90\x93\x16\x83\x83\x01R\x84\x01\x91\x90\x91R`\x03\x84\x01T``\x84\x01R`\x04\x90\x93\x01T`\x80\x90\x92\x01\x91\x90\x91R\x91\x83R\x92\x01\x91\x01a\x01\xE2V[PPPP\x81R` \x01`\x01\x80T\x80` \x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01`\0\x90[\x82\x82\x10\x15a\x04\xD1W\x83\x82\x90`\0R` `\0 \x90`\x06\x02\x01`@Q\x80`\xC0\x01`@R\x90\x81`\0\x82\x01\x80Ta\x03R\x90a\x0F\xE6V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x03~\x90a\x0F\xE6V[\x80\x15a\x03\xCBW\x80`\x1F\x10a\x03\xA0Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x03\xCBV[\x82\x01\x91\x90`\0R` `\0 \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x03\xAEW\x82\x90\x03`\x1F\x16\x82\x01\x91[PPP\x91\x83RPP`\x01\x82\x01T`\xFF\x90\x81\x16` \x80\x84\x01\x91\x90\x91R`@\x80Q\x80\x82\x01\x82R`\x02\x86\x01T\x80\x85\x16\x82Ra\x01\0\x90\x04\x84\x16\x81\x84\x01R\x81\x85\x01R`\x03\x85\x01T\x90\x92\x16``\x84\x01R`\x04\x84\x01\x80T\x83Q\x81\x84\x02\x81\x01\x84\x01\x90\x94R\x80\x84R`\x80\x90\x94\x01\x93\x90\x91\x83\x01\x82\x82\x80\x15a\x04aW` \x02\x82\x01\x91\x90`\0R` `\0 \x90[\x81T\x81R` \x01\x90`\x01\x01\x90\x80\x83\x11a\x04MW[PPPPP\x81R` \x01`\x05\x82\x01\x80T\x80` \x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80T\x80\x15a\x04\xB9W` \x02\x82\x01\x91\x90`\0R` `\0 \x90[\x81T\x81R` \x01\x90`\x01\x01\x90\x80\x83\x11a\x04\xA5W[PPPPP\x81RPP\x81R` \x01\x90`\x01\x01\x90a\x03\x1FV[PPP\x91RP\x91\x90PV[a\x04\xE6\x82\x82a\x05\xBCV[a\x04\xEFCa\x08^V[PPV[\x82\x81\x14a\x05GW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1C`$\x82\x01R\x7FModelRegistry: invalid input\0\0\0\0`D\x82\x01R`d\x01[`@Q\x80\x91\x03\x90\xFD[`\0[\x83\x81\x10\x15a\x05\xACWa\x05\x9A\x85\x85\x83\x81\x81\x10a\x05gWa\x05ga\x10 V[\x90P` \x02\x01` \x81\x01\x90a\x05|\x91\x90a\x106V[\x84\x84\x84\x81\x81\x10a\x05\x8EWa\x05\x8Ea\x10 V[\x90P` \x02\x015a\x05\xBCV[\x80a\x05\xA4\x81a\x10nV[\x91PPa\x05JV[Pa\x05\xB6Ca\x08^V[PPPPV[`\0`\x01\x83`\xFF\x16\x81T\x81\x10a\x05\xD4Wa\x05\xD4a\x10 V[\x90`\0R` `\0 \x90`\x06\x02\x01`@Q\x80`\xC0\x01`@R\x90\x81`\0\x82\x01\x80Ta\x05\xFD\x90a\x0F\xE6V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x06)\x90a\x0F\xE6V[\x80\x15a\x06vW\x80`\x1F\x10a\x06KWa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x06vV[\x82\x01\x91\x90`\0R` `\0 \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x06YW\x82\x90\x03`\x1F\x16\x82\x01\x91[PPP\x91\x83RPP`\x01\x82\x01T`\xFF\x90\x81\x16` \x80\x84\x01\x91\x90\x91R`@\x80Q\x80\x82\x01\x82R`\x02\x86\x01T\x80\x85\x16\x82Ra\x01\0\x90\x04\x84\x16\x81\x84\x01R\x81\x85\x01R`\x03\x85\x01T\x90\x92\x16``\x84\x01R`\x04\x84\x01\x80T\x83Q\x81\x84\x02\x81\x01\x84\x01\x90\x94R\x80\x84R`\x80\x90\x94\x01\x93\x90\x91\x83\x01\x82\x82\x80\x15a\x07\x0CW` \x02\x82\x01\x91\x90`\0R` `\0 \x90[\x81T\x81R` \x01\x90`\x01\x01\x90\x80\x83\x11a\x06\xF8W[PPPPP\x81R` \x01`\x05\x82\x01\x80T\x80` \x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80T\x80\x15a\x07dW` \x02\x82\x01\x91\x90`\0R` `\0 \x90[\x81T\x81R` \x01\x90`\x01\x01\x90\x80\x83\x11a\x07PW[PPPPP\x81RPP\x90Pa\x07x\x81a\x08\xBFV[\x15a\x07\xB1W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\t`$\x82\x01Rh\x1A[\x9A\x1AX\x9A]\x19Y`\xBA\x1B`D\x82\x01R`d\x01a\x05>V[\x80` \x01Q`\xFF\x16\x83`\xFF\x16\x14a\x07\xCAWa\x07\xCAa\x10\x87V[`\0[`\0T`\xFF\x90\x81\x16\x90\x82\x16\x10\x15a\x07\xFBWa\x07\xE9\x81\x83\x85a\t\xF9V[\x80a\x07\xF3\x81a\x10\x9DV[\x91PPa\x07\xCDV[P`\x02\x80T\x90`\0a\x08\x0C\x83a\x10nV[\x91\x90PUP\x81\x83`\xFF\x16\x82``\x01Q`\xFF\x16\x7FP\xE4\xA5+\x07r\xBE\xD9\xF0j}?}\xFAf\xD76@\x06z\\\xC7zs\xC2EV\xCC\xC9\0\xFA\x08`\x02T`@Qa\x08Q\x91\x81R` \x01\x90V[`@Q\x80\x91\x03\x90\xA4PPPV[`\0[`\t\x81`\xFF\x16\x10\x15a\x08\xB9W`\x03a\x08z\x82`\x01a\x10\xBCV[`\xFF\x16`\n\x81\x10a\x08\x8DWa\x08\x8Da\x10 V[\x01T`\x03\x82`\xFF\x16`\n\x81\x10a\x08\xA5Wa\x08\xA5a\x10 V[\x01U\x80a\x08\xB1\x81a\x10\x9DV[\x91PPa\x08aV[P`\x0CUV[`\0\x80[`\x01`\xFF\x82\x16\x10\x15a\t\xF0W\x82`\xA0\x01Q\x81`\xFF\x16\x81Q\x81\x10a\x08\xE8Wa\x08\xE8a\x10 V[` \x02` \x01\x01Q`\0\x14a\t\xDEW`\0\x83`\xA0\x01Q\x82`\xFF\x16\x81Q\x81\x10a\t\x12Wa\t\x12a\x10 V[` \x02` \x01\x01Q\x12\x15a\t\x81W`\0\x83`\xA0\x01Q\x82`\xFF\x16\x81Q\x81\x10a\t;Wa\t;a\x10 V[` \x02` \x01\x01Q`\r\x83`\xFF\x16\x81T\x81\x10a\tYWa\tYa\x10 V[\x90`\0R` `\0 \x01Ta\tn\x91\x90a\x10\xDBV[\x12a\t|WP`\x01\x92\x91PPV[a\t\xDEV[`\0\x83`\xA0\x01Q\x82`\xFF\x16\x81Q\x81\x10a\t\x9CWa\t\x9Ca\x10 V[` \x02` \x01\x01Q`\r\x83`\xFF\x16\x81T\x81\x10a\t\xBAWa\t\xBAa\x10 V[\x90`\0R` `\0 \x01Ta\t\xCF\x91\x90a\x11\x03V[\x12\x15a\t\xDEWP`\x01\x92\x91PPV[\x80a\t\xE8\x81a\x10\x9DV[\x91PPa\x08\xC3V[P`\0\x92\x91PPV[`\0\x81\x11a\n:W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x0E`$\x82\x01Rm4\xB7;0\xB64\xB2\x109\xB1\xB0\xB60\xB9`\x91\x1B`D\x82\x01R`d\x01a\x05>V[\x81`\x80\x01Q\x83`\xFF\x16\x81Q\x81\x10a\nSWa\nSa\x10 V[` \x02` \x01\x01Q`\0\x14a\x0B\xEBW\x80\x82`\x80\x01Q\x84`\xFF\x16\x81Q\x81\x10a\n|Wa\n|a\x10 V[` \x02` \x01\x01Qa\n\x8E\x91\x90a\x11*V[`\r\x84`\xFF\x16\x81T\x81\x10a\n\xA4Wa\n\xA4a\x10 V[\x90`\0R` `\0 \x01Ta\n\xB9\x91\x90a\x10\xDBV[`\r\x84`\xFF\x16\x81T\x81\x10a\n\xCFWa\n\xCFa\x10 V[\x90`\0R` `\0 \x01\x81\x90UP`\0`\r\x84`\xFF\x16\x81T\x81\x10a\n\xF5Wa\n\xF5a\x10 V[\x90`\0R` `\0 \x01T\x12\x15a\x0B:W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\t`$\x82\x01Rhunderflow`\xB8\x1B`D\x82\x01R`d\x01a\x05>V[`\0\x80\x84`\xFF\x16\x81T\x81\x10a\x0BQWa\x0BQa\x10 V[\x90`\0R` `\0 \x90`\x05\x02\x01`\x04\x01T\x11\x15a\x0B\xEBW`\0\x83`\xFF\x16\x81T\x81\x10a\x0B\x7FWa\x0B\x7Fa\x10 V[\x90`\0R` `\0 \x90`\x05\x02\x01`\x04\x01T`\r\x84`\xFF\x16\x81T\x81\x10a\x0B\xA7Wa\x0B\xA7a\x10 V[\x90`\0R` `\0 \x01T\x13\x15a\x0B\xEBW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x08`$\x82\x01Rgoverflow`\xC0\x1B`D\x82\x01R`d\x01a\x05>V[PPPV[`@Q\x80`\xA0\x01`@R\x80a\x0C\x03a\x0C%V[\x81R` \x01`\0\x81R` \x01``\x81R` \x01``\x81R` \x01``\x81RP\x90V[`@Q\x80a\x01@\x01`@R\x80`\n\x90` \x82\x02\x806\x837P\x91\x92\x91PPV[`\0` \x82\x84\x03\x12\x15a\x0CVW`\0\x80\xFD[P5\x91\x90PV[`\0\x81Q\x80\x84R` \x80\x85\x01\x94P\x80\x84\x01`\0[\x83\x81\x10\x15a\x0C\x8DW\x81Q\x87R\x95\x82\x01\x95\x90\x82\x01\x90`\x01\x01a\x0CqV[P\x94\x95\x94PPPPPV[`\0\x81Q\x80\x84R`\0[\x81\x81\x10\x15a\x0C\xBEW` \x81\x85\x01\x81\x01Q\x86\x83\x01\x82\x01R\x01a\x0C\xA2V[P`\0` \x82\x86\x01\x01R` `\x1F\x19`\x1F\x83\x01\x16\x85\x01\x01\x91PP\x92\x91PPV[`\0\x81Q\x80\x84R` \x80\x85\x01\x80\x81\x96P\x83`\x05\x1B\x81\x01\x91P\x82\x86\x01`\0[\x85\x81\x10\x15a\r{W\x82\x84\x03\x89R\x81Q`\xC0\x81Q\x81\x87Ra\r\x1E\x82\x88\x01\x82a\x0C\x98V[\x91PP`\xFF\x87\x83\x01Q\x16\x87\x87\x01R`@\x80\x83\x01Qa\rN\x82\x89\x01\x82\x80Q`\xFF\x90\x81\x16\x83R` \x91\x82\x01Q\x16\x91\x01RV[PP``\x82\x01Q`\x80\x87\x81\x01\x91\x90\x91R\x90\x91\x01Q`\xA0\x90\x95\x01\x94\x90\x94R\x97\x84\x01\x97\x90\x84\x01\x90`\x01\x01a\x0C\xFCV[P\x91\x97\x96PPPPPPPV[`\0\x81Q\x80\x84R` \x80\x85\x01\x80\x81\x96P\x83`\x05\x1B\x81\x01\x91P\x82\x86\x01`\0[\x85\x81\x10\x15a\r{W\x82\x84\x03\x89R\x81Q`\xE0\x81Q\x81\x87Ra\r\xC8\x82\x88\x01\x82a\x0C\x98V[\x83\x89\x01Q`\xFF\x90\x81\x16\x89\x8B\x01R`@\x80\x86\x01Q\x80Q\x83\x16\x82\x8C\x01R` \x81\x01Q\x83\x16``\x8C\x01R\x92\x94P\x92P\x90P``\x84\x01Q\x91P`\x80\x81\x83\x16\x81\x8A\x01R\x80\x85\x01Q\x92PPP`\xA0\x87\x83\x03\x81\x89\x01Ra\x0E!\x83\x83a\x0C]V[\x93\x01Q\x87\x84\x03`\xC0\x89\x01R\x92\x91Pa\x0E;\x90P\x81\x83a\x0C]V[\x9A\x87\x01\x9A\x95PPP\x90\x84\x01\x90`\x01\x01a\r\xA6V[` \x80\x82R\x82Q`\0\x91\x90\x82\x84\x83\x01[`\n\x82\x10\x15a\x0E~W\x82Q\x81R\x91\x83\x01\x91`\x01\x91\x90\x91\x01\x90\x83\x01a\x0E_V[PPP\x83\x01Qa\x01`\x83\x01R`@\x83\x01Qa\x01\xC0a\x01\x80\x84\x01\x81\x90Ra\x0E\xA8a\x01\xE0\x85\x01\x83a\x0C]V[\x91P``\x85\x01Q`\x1F\x19\x80\x86\x85\x03\x01a\x01\xA0\x87\x01Ra\x0E\xC7\x84\x83a\x0C\xDEV[\x93P`\x80\x87\x01Q\x91P\x80\x86\x85\x03\x01\x83\x87\x01RPa\x0E\xE4\x83\x82a\r\x88V[\x96\x95PPPPPPV[\x805`\xFF\x81\x16\x81\x14a\x0E\xFFW`\0\x80\xFD[\x91\x90PV[`\0\x80`@\x83\x85\x03\x12\x15a\x0F\x17W`\0\x80\xFD[a\x0F \x83a\x0E\xEEV[\x94` \x93\x90\x93\x015\x93PPPV[`\0\x80\x83`\x1F\x84\x01\x12a\x0F@W`\0\x80\xFD[P\x815g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x0FXW`\0\x80\xFD[` \x83\x01\x91P\x83` \x82`\x05\x1B\x85\x01\x01\x11\x15a\x0FsW`\0\x80\xFD[\x92P\x92\x90PV[`\0\x80`\0\x80`@\x85\x87\x03\x12\x15a\x0F\x90W`\0\x80\xFD[\x845g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x80\x82\x11\x15a\x0F\xA8W`\0\x80\xFD[a\x0F\xB4\x88\x83\x89\x01a\x0F.V[\x90\x96P\x94P` \x87\x015\x91P\x80\x82\x11\x15a\x0F\xCDW`\0\x80\xFD[Pa\x0F\xDA\x87\x82\x88\x01a\x0F.V[\x95\x98\x94\x97P\x95PPPPV[`\x01\x81\x81\x1C\x90\x82\x16\x80a\x0F\xFAW`\x7F\x82\x16\x91P[` \x82\x10\x81\x03a\x10\x1AWcNH{q`\xE0\x1B`\0R`\"`\x04R`$`\0\xFD[P\x91\x90PV[cNH{q`\xE0\x1B`\0R`2`\x04R`$`\0\xFD[`\0` \x82\x84\x03\x12\x15a\x10HW`\0\x80\xFD[a\x10Q\x82a\x0E\xEEV[\x93\x92PPPV[cNH{q`\xE0\x1B`\0R`\x11`\x04R`$`\0\xFD[`\0`\x01\x82\x01a\x10\x80Wa\x10\x80a\x10XV[P`\x01\x01\x90V[cNH{q`\xE0\x1B`\0R`\x01`\x04R`$`\0\xFD[`\0`\xFF\x82\x16`\xFF\x81\x03a\x10\xB3Wa\x10\xB3a\x10XV[`\x01\x01\x92\x91PPV[`\xFF\x81\x81\x16\x83\x82\x16\x01\x90\x81\x11\x15a\x10\xD5Wa\x10\xD5a\x10XV[\x92\x91PPV[\x80\x82\x01\x82\x81\x12`\0\x83\x12\x80\x15\x82\x16\x82\x15\x82\x16\x17\x15a\x10\xFBWa\x10\xFBa\x10XV[PP\x92\x91PPV[\x81\x81\x03`\0\x83\x12\x80\x15\x83\x83\x13\x16\x83\x83\x12\x82\x16\x17\x15a\x11#Wa\x11#a\x10XV[P\x92\x91PPV[\x80\x82\x02`\0\x82\x12`\x01`\xFF\x1B\x84\x14\x16\x15a\x11FWa\x11Fa\x10XV[\x81\x81\x05\x83\x14\x82\x15\x17a\x10\xD5Wa\x10\xD5a\x10XV\xFE\xA2dipfsX\"\x12 C\xBA\x8BiP\xA9\xCDh\xD9h=\xA7\xA0\x08O(\xF8tvI#\xF9\r\xD4\xF7\xCF\x01}\x08MG\x94dsolcC\0\x08\x15\x003",
    );
    /**```solidity
struct Head { uint256[10] latestBlocks; uint256 sequence; int256[] state; Place[] places; Transition[] transitions; }
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct Head {
        pub latestBlocks: [alloy::sol_types::private::U256; 10usize],
        pub sequence: alloy::sol_types::private::U256,
        pub state: alloy::sol_types::private::Vec<alloy::sol_types::private::I256>,
        pub places: alloy::sol_types::private::Vec<
            <Place as alloy::sol_types::SolType>::RustType,
        >,
        pub transitions: alloy::sol_types::private::Vec<
            <Transition as alloy::sol_types::SolType>::RustType,
        >,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::FixedArray<
                alloy::sol_types::sol_data::Uint<256>,
                10usize,
            >,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Int<256>>,
            alloy::sol_types::sol_data::Array<Place>,
            alloy::sol_types::sol_data::Array<Transition>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            [alloy::sol_types::private::U256; 10usize],
            alloy::sol_types::private::U256,
            alloy::sol_types::private::Vec<alloy::sol_types::private::I256>,
            alloy::sol_types::private::Vec<
                <Place as alloy::sol_types::SolType>::RustType,
            >,
            alloy::sol_types::private::Vec<
                <Transition as alloy::sol_types::SolType>::RustType,
            >,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<Head> for UnderlyingRustTuple<'_> {
            fn from(value: Head) -> Self {
                (
                    value.latestBlocks,
                    value.sequence,
                    value.state,
                    value.places,
                    value.transitions,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for Head {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    latestBlocks: tuple.0,
                    sequence: tuple.1,
                    state: tuple.2,
                    places: tuple.3,
                    transitions: tuple.4,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for Head {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for Head {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedArray<
                        alloy::sol_types::sol_data::Uint<256>,
                        10usize,
                    > as alloy_sol_types::SolType>::tokenize(&self.latestBlocks),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.sequence),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Int<256>,
                    > as alloy_sol_types::SolType>::tokenize(&self.state),
                    <alloy::sol_types::sol_data::Array<
                        Place,
                    > as alloy_sol_types::SolType>::tokenize(&self.places),
                    <alloy::sol_types::sol_data::Array<
                        Transition,
                    > as alloy_sol_types::SolType>::tokenize(&self.transitions),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for Head {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for Head {
            const NAME: &'static str = "Head";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "Head(uint256[10] latestBlocks,uint256 sequence,int256[] state,Place[] places,Transition[] transitions)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                let mut components = alloy_sol_types::private::Vec::with_capacity(2);
                components
                    .push(<Place as alloy_sol_types::SolStruct>::eip712_root_type());
                components
                    .extend(<Place as alloy_sol_types::SolStruct>::eip712_components());
                components
                    .push(
                        <Transition as alloy_sol_types::SolStruct>::eip712_root_type(),
                    );
                components
                    .extend(
                        <Transition as alloy_sol_types::SolStruct>::eip712_components(),
                    );
                components
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::FixedArray<
                        alloy::sol_types::sol_data::Uint<256>,
                        10usize,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.latestBlocks)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.sequence)
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Int<256>,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.state)
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        Place,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.places)
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        Transition,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.transitions)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for Head {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::FixedArray<
                        alloy::sol_types::sol_data::Uint<256>,
                        10usize,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.latestBlocks,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sequence,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Int<256>,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.state)
                    + <alloy::sol_types::sol_data::Array<
                        Place,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.places,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        Transition,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.transitions,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::FixedArray<
                    alloy::sol_types::sol_data::Uint<256>,
                    10usize,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.latestBlocks,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sequence,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::Int<256>,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.state,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    Place,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.places,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    Transition,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.transitions,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct Place { string label; uint8 offset; Position position; uint256 initial; uint256 capacity; }
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct Place {
        pub label: alloy::sol_types::private::String,
        pub offset: u8,
        pub position: <Position as alloy::sol_types::SolType>::RustType,
        pub initial: alloy::sol_types::private::U256,
        pub capacity: alloy::sol_types::private::U256,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::String,
            alloy::sol_types::sol_data::Uint<8>,
            Position,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::String,
            u8,
            <Position as alloy::sol_types::SolType>::RustType,
            alloy::sol_types::private::U256,
            alloy::sol_types::private::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<Place> for UnderlyingRustTuple<'_> {
            fn from(value: Place) -> Self {
                (
                    value.label,
                    value.offset,
                    value.position,
                    value.initial,
                    value.capacity,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for Place {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    label: tuple.0,
                    offset: tuple.1,
                    position: tuple.2,
                    initial: tuple.3,
                    capacity: tuple.4,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for Place {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for Place {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.label,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::tokenize(&self.offset),
                    <Position as alloy_sol_types::SolType>::tokenize(&self.position),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.initial),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.capacity),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for Place {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for Place {
            const NAME: &'static str = "Place";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "Place(string label,uint8 offset,Position position,uint256 initial,uint256 capacity)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                let mut components = alloy_sol_types::private::Vec::with_capacity(1);
                components
                    .push(<Position as alloy_sol_types::SolStruct>::eip712_root_type());
                components
                    .extend(
                        <Position as alloy_sol_types::SolStruct>::eip712_components(),
                    );
                components
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::eip712_data_word(
                            &self.label,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.offset)
                        .0,
                    <Position as alloy_sol_types::SolType>::eip712_data_word(
                            &self.position,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.initial)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.capacity)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for Place {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.label,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.offset,
                    )
                    + <Position as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.position,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.initial,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.capacity,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.label,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.offset,
                    out,
                );
                <Position as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.position,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.initial,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.capacity,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct Position { uint8 x; uint8 y; }
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct Position {
        pub x: u8,
        pub y: u8,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<8>,
            alloy::sol_types::sol_data::Uint<8>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (u8, u8);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<Position> for UnderlyingRustTuple<'_> {
            fn from(value: Position) -> Self {
                (value.x, value.y)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for Position {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { x: tuple.0, y: tuple.1 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for Position {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for Position {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::tokenize(&self.x),
                    <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::tokenize(&self.y),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for Position {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for Position {
            const NAME: &'static str = "Position";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed("Position(uint8 x,uint8 y)")
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.x)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.y)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for Position {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.x)
                    + <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.y)
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(&rust.x, out);
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(&rust.y, out);
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct Transition { string label; uint8 offset; Position position; uint8 role; int256[] delta; int256[] guard; }
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct Transition {
        pub label: alloy::sol_types::private::String,
        pub offset: u8,
        pub position: <Position as alloy::sol_types::SolType>::RustType,
        pub role: u8,
        pub delta: alloy::sol_types::private::Vec<alloy::sol_types::private::I256>,
        pub guard: alloy::sol_types::private::Vec<alloy::sol_types::private::I256>,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::String,
            alloy::sol_types::sol_data::Uint<8>,
            Position,
            alloy::sol_types::sol_data::Uint<8>,
            alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Int<256>>,
            alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Int<256>>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::String,
            u8,
            <Position as alloy::sol_types::SolType>::RustType,
            u8,
            alloy::sol_types::private::Vec<alloy::sol_types::private::I256>,
            alloy::sol_types::private::Vec<alloy::sol_types::private::I256>,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<Transition> for UnderlyingRustTuple<'_> {
            fn from(value: Transition) -> Self {
                (
                    value.label,
                    value.offset,
                    value.position,
                    value.role,
                    value.delta,
                    value.guard,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for Transition {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    label: tuple.0,
                    offset: tuple.1,
                    position: tuple.2,
                    role: tuple.3,
                    delta: tuple.4,
                    guard: tuple.5,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for Transition {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for Transition {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.label,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::tokenize(&self.offset),
                    <Position as alloy_sol_types::SolType>::tokenize(&self.position),
                    <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::tokenize(&self.role),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Int<256>,
                    > as alloy_sol_types::SolType>::tokenize(&self.delta),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Int<256>,
                    > as alloy_sol_types::SolType>::tokenize(&self.guard),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for Transition {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for Transition {
            const NAME: &'static str = "Transition";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "Transition(string label,uint8 offset,Position position,uint8 role,int256[] delta,int256[] guard)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                let mut components = alloy_sol_types::private::Vec::with_capacity(1);
                components
                    .push(<Position as alloy_sol_types::SolStruct>::eip712_root_type());
                components
                    .extend(
                        <Position as alloy_sol_types::SolStruct>::eip712_components(),
                    );
                components
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::eip712_data_word(
                            &self.label,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.offset)
                        .0,
                    <Position as alloy_sol_types::SolType>::eip712_data_word(
                            &self.position,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.role)
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Int<256>,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.delta)
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Int<256>,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.guard)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for Transition {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.label,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.offset,
                    )
                    + <Position as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.position,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.role)
                    + <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Int<256>,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.delta)
                    + <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Int<256>,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.guard)
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.label,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.offset,
                    out,
                );
                <Position as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.position,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.role,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::Int<256>,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.delta,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::Int<256>,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.guard,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**Event with signature `SignaledEvent(uint8,uint8,uint256,uint256)` and selector `0x50e4a52b0772bed9f06a7d3f7dfa66d73640067a5cc77a73c24556ccc900fa08`.
```solidity
event SignaledEvent(uint8 indexed role, uint8 indexed actionId, uint256 indexed scalar, uint256 sequence);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    #[derive(Clone)]
    pub struct SignaledEvent {
        #[allow(missing_docs)]
        pub role: u8,
        #[allow(missing_docs)]
        pub actionId: u8,
        #[allow(missing_docs)]
        pub scalar: alloy::sol_types::private::U256,
        #[allow(missing_docs)]
        pub sequence: alloy::sol_types::private::U256,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for SignaledEvent {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<8>,
                alloy::sol_types::sol_data::Uint<8>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            const SIGNATURE: &'static str = "SignaledEvent(uint8,uint8,uint256,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                80u8,
                228u8,
                165u8,
                43u8,
                7u8,
                114u8,
                190u8,
                217u8,
                240u8,
                106u8,
                125u8,
                63u8,
                125u8,
                250u8,
                102u8,
                215u8,
                54u8,
                64u8,
                6u8,
                122u8,
                92u8,
                199u8,
                122u8,
                115u8,
                194u8,
                69u8,
                86u8,
                204u8,
                201u8,
                0u8,
                250u8,
                8u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    role: topics.1,
                    actionId: topics.2,
                    scalar: topics.3,
                    sequence: data.0,
                }
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.sequence),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.role.clone(),
                    self.actionId.clone(),
                    self.scalar.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.role);
                out[2usize] = <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.actionId);
                out[3usize] = <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.scalar);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for SignaledEvent {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&SignaledEvent> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &SignaledEvent) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Function with signature `context()` and selector `0xd0496d6a`.
```solidity
function context() external view returns (Head memory);
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct contextCall {}
    ///Container type for the return parameters of the [`context()`](contextCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct contextReturn {
        pub _0: <Head as alloy::sol_types::SolType>::RustType,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<contextCall> for UnderlyingRustTuple<'_> {
                fn from(value: contextCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for contextCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (Head,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <Head as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<contextReturn> for UnderlyingRustTuple<'_> {
                fn from(value: contextReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for contextReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for contextCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = contextReturn;
            type ReturnTuple<'a> = (Head,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "context()";
            const SELECTOR: [u8; 4] = [208u8, 73u8, 109u8, 106u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `latestBlocks(uint256)` and selector `0x6ee376e6`.
```solidity
function latestBlocks(uint256) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct latestBlocksCall {
        pub _0: alloy::sol_types::private::U256,
    }
    ///Container type for the return parameters of the [`latestBlocks(uint256)`](latestBlocksCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct latestBlocksReturn {
        pub _0: alloy::sol_types::private::U256,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::U256,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<latestBlocksCall> for UnderlyingRustTuple<'_> {
                fn from(value: latestBlocksCall) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for latestBlocksCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::U256,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<latestBlocksReturn> for UnderlyingRustTuple<'_> {
                fn from(value: latestBlocksReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for latestBlocksReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for latestBlocksCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = latestBlocksReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "latestBlocks(uint256)";
            const SELECTOR: [u8; 4] = [110u8, 227u8, 118u8, 230u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self._0),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `sequence()` and selector `0x529d15cc`.
```solidity
function sequence() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct sequenceCall {}
    ///Container type for the return parameters of the [`sequence()`](sequenceCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct sequenceReturn {
        pub _0: alloy::sol_types::private::U256,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<sequenceCall> for UnderlyingRustTuple<'_> {
                fn from(value: sequenceCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for sequenceCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::U256,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<sequenceReturn> for UnderlyingRustTuple<'_> {
                fn from(value: sequenceReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for sequenceReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for sequenceCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = sequenceReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "sequence()";
            const SELECTOR: [u8; 4] = [82u8, 157u8, 21u8, 204u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `signal(uint8,uint256)` and selector `0xddc3b187`.
```solidity
function signal(uint8 action, uint256 scalar) external;
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct signalCall {
        pub action: u8,
        pub scalar: alloy::sol_types::private::U256,
    }
    ///Container type for the return parameters of the [`signal(uint8,uint256)`](signalCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct signalReturn {}
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<8>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u8, alloy::sol_types::private::U256);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<signalCall> for UnderlyingRustTuple<'_> {
                fn from(value: signalCall) -> Self {
                    (value.action, value.scalar)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for signalCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        action: tuple.0,
                        scalar: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<signalReturn> for UnderlyingRustTuple<'_> {
                fn from(value: signalReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for signalReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for signalCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<8>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = signalReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "signal(uint8,uint256)";
            const SELECTOR: [u8; 4] = [221u8, 195u8, 177u8, 135u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::tokenize(&self.action),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalar),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `signalMany(uint8[],uint256[])` and selector `0xfff01fe2`.
```solidity
function signalMany(uint8[] memory actions, uint256[] memory scalars) external;
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct signalManyCall {
        pub actions: alloy::sol_types::private::Vec<u8>,
        pub scalars: alloy::sol_types::private::Vec<alloy::sol_types::private::U256>,
    }
    ///Container type for the return parameters of the [`signalMany(uint8[],uint256[])`](signalManyCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct signalManyReturn {}
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<8>>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<u8>,
                alloy::sol_types::private::Vec<alloy::sol_types::private::U256>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<signalManyCall> for UnderlyingRustTuple<'_> {
                fn from(value: signalManyCall) -> Self {
                    (value.actions, value.scalars)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for signalManyCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        actions: tuple.0,
                        scalars: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<signalManyReturn> for UnderlyingRustTuple<'_> {
                fn from(value: signalManyReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for signalManyReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for signalManyCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<8>>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = signalManyReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "signalMany(uint8[],uint256[])";
            const SELECTOR: [u8; 4] = [255u8, 240u8, 31u8, 226u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Uint<8>,
                    > as alloy_sol_types::SolType>::tokenize(&self.actions),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Uint<256>,
                    > as alloy_sol_types::SolType>::tokenize(&self.scalars),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `state(uint256)` and selector `0x3e4f49e6`.
```solidity
function state(uint256) external view returns (int256);
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct stateCall {
        pub _0: alloy::sol_types::private::U256,
    }
    ///Container type for the return parameters of the [`state(uint256)`](stateCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct stateReturn {
        pub _0: alloy::sol_types::private::I256,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::U256,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<stateCall> for UnderlyingRustTuple<'_> {
                fn from(value: stateCall) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for stateCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Int<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::I256,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<stateReturn> for UnderlyingRustTuple<'_> {
                fn from(value: stateReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for stateReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for stateCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = stateReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Int<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "state(uint256)";
            const SELECTOR: [u8; 4] = [62u8, 79u8, 73u8, 230u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self._0),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    ///Container for all the [`MyStateMachine`](self) function calls.
    pub enum MyStateMachineCalls {
        context(contextCall),
        latestBlocks(latestBlocksCall),
        sequence(sequenceCall),
        signal(signalCall),
        signalMany(signalManyCall),
        state(stateCall),
    }
    #[automatically_derived]
    impl MyStateMachineCalls {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [62u8, 79u8, 73u8, 230u8],
            [82u8, 157u8, 21u8, 204u8],
            [110u8, 227u8, 118u8, 230u8],
            [208u8, 73u8, 109u8, 106u8],
            [221u8, 195u8, 177u8, 135u8],
            [255u8, 240u8, 31u8, 226u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for MyStateMachineCalls {
        const NAME: &'static str = "MyStateMachineCalls";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 6usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::context(_) => <contextCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::latestBlocks(_) => {
                    <latestBlocksCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::sequence(_) => <sequenceCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::signal(_) => <signalCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::signalMany(_) => {
                    <signalManyCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::state(_) => <stateCall as alloy_sol_types::SolCall>::SELECTOR,
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(unsafe_code, non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
                bool,
            ) -> alloy_sol_types::Result<MyStateMachineCalls>] = &[
                {
                    fn state(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MyStateMachineCalls> {
                        <stateCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MyStateMachineCalls::state)
                    }
                    state
                },
                {
                    fn sequence(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MyStateMachineCalls> {
                        <sequenceCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MyStateMachineCalls::sequence)
                    }
                    sequence
                },
                {
                    fn latestBlocks(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MyStateMachineCalls> {
                        <latestBlocksCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MyStateMachineCalls::latestBlocks)
                    }
                    latestBlocks
                },
                {
                    fn context(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MyStateMachineCalls> {
                        <contextCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MyStateMachineCalls::context)
                    }
                    context
                },
                {
                    fn signal(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MyStateMachineCalls> {
                        <signalCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MyStateMachineCalls::signal)
                    }
                    signal
                },
                {
                    fn signalMany(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MyStateMachineCalls> {
                        <signalManyCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MyStateMachineCalls::signalMany)
                    }
                    signalMany
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            (unsafe { DECODE_SHIMS.get_unchecked(idx) })(data, validate)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::context(inner) => {
                    <contextCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::latestBlocks(inner) => {
                    <latestBlocksCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::sequence(inner) => {
                    <sequenceCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::signal(inner) => {
                    <signalCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::signalMany(inner) => {
                    <signalManyCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::state(inner) => {
                    <stateCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::context(inner) => {
                    <contextCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::latestBlocks(inner) => {
                    <latestBlocksCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::sequence(inner) => {
                    <sequenceCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::signal(inner) => {
                    <signalCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::signalMany(inner) => {
                    <signalManyCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::state(inner) => {
                    <stateCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
            }
        }
    }
    ///Container for all the [`MyStateMachine`](self) events.
    pub enum MyStateMachineEvents {
        SignaledEvent(SignaledEvent),
    }
    #[automatically_derived]
    impl MyStateMachineEvents {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 32usize]] = &[
            [
                80u8,
                228u8,
                165u8,
                43u8,
                7u8,
                114u8,
                190u8,
                217u8,
                240u8,
                106u8,
                125u8,
                63u8,
                125u8,
                250u8,
                102u8,
                215u8,
                54u8,
                64u8,
                6u8,
                122u8,
                92u8,
                199u8,
                122u8,
                115u8,
                194u8,
                69u8,
                86u8,
                204u8,
                201u8,
                0u8,
                250u8,
                8u8,
            ],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolEventInterface for MyStateMachineEvents {
        const NAME: &'static str = "MyStateMachineEvents";
        const COUNT: usize = 1usize;
        fn decode_raw_log(
            topics: &[alloy_sol_types::Word],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            match topics.first().copied() {
                Some(<SignaledEvent as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <SignaledEvent as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::SignaledEvent)
                }
                _ => {
                    alloy_sol_types::private::Err(alloy_sol_types::Error::InvalidLog {
                        name: <Self as alloy_sol_types::SolEventInterface>::NAME,
                        log: alloy_sol_types::private::Box::new(
                            alloy_sol_types::private::LogData::new_unchecked(
                                topics.to_vec(),
                                data.to_vec().into(),
                            ),
                        ),
                    })
                }
            }
        }
    }
    #[automatically_derived]
    impl alloy_sol_types::private::IntoLogData for MyStateMachineEvents {
        fn to_log_data(&self) -> alloy_sol_types::private::LogData {
            match self {
                Self::SignaledEvent(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
            }
        }
        fn into_log_data(self) -> alloy_sol_types::private::LogData {
            match self {
                Self::SignaledEvent(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
            }
        }
    }
    use alloy::contract as alloy_contract;
    /**Creates a new wrapper around an on-chain [`MyStateMachine`](self) contract instance.

See the [wrapper's documentation](`MyStateMachineInstance`) for more details.*/
    #[inline]
    pub const fn new<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        address: alloy_sol_types::private::Address,
        provider: P,
    ) -> MyStateMachineInstance<T, P, N> {
        MyStateMachineInstance::<T, P, N>::new(address, provider)
    }
    /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
    #[inline]
    pub fn deploy<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
    ) -> impl ::core::future::Future<
        Output = alloy_contract::Result<MyStateMachineInstance<T, P, N>>,
    > {
        MyStateMachineInstance::<T, P, N>::deploy(provider)
    }
    /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
    #[inline]
    pub fn deploy_builder<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(provider: P) -> alloy_contract::RawCallBuilder<T, P, N> {
        MyStateMachineInstance::<T, P, N>::deploy_builder(provider)
    }
    /**A [`MyStateMachine`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`MyStateMachine`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
    #[derive(Clone)]
    pub struct MyStateMachineInstance<T, P, N = alloy_contract::private::Ethereum> {
        address: alloy_sol_types::private::Address,
        provider: P,
        _network_transport: ::core::marker::PhantomData<(N, T)>,
    }
    #[automatically_derived]
    impl<T, P, N> ::core::fmt::Debug for MyStateMachineInstance<T, P, N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple("MyStateMachineInstance").field(&self.address).finish()
        }
    }
    /// Instantiation and getters/setters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > MyStateMachineInstance<T, P, N> {
        /**Creates a new wrapper around an on-chain [`MyStateMachine`](self) contract instance.

See the [wrapper's documentation](`MyStateMachineInstance`) for more details.*/
        #[inline]
        pub const fn new(
            address: alloy_sol_types::private::Address,
            provider: P,
        ) -> Self {
            Self {
                address,
                provider,
                _network_transport: ::core::marker::PhantomData,
            }
        }
        /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
        #[inline]
        pub async fn deploy(
            provider: P,
        ) -> alloy_contract::Result<MyStateMachineInstance<T, P, N>> {
            let call_builder = Self::deploy_builder(provider);
            let contract_address = call_builder.deploy().await?;
            Ok(Self::new(contract_address, call_builder.provider))
        }
        /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
        #[inline]
        pub fn deploy_builder(provider: P) -> alloy_contract::RawCallBuilder<T, P, N> {
            alloy_contract::RawCallBuilder::new_raw_deploy(
                provider,
                ::core::clone::Clone::clone(&BYTECODE),
            )
        }
        /// Returns a reference to the address.
        #[inline]
        pub const fn address(&self) -> &alloy_sol_types::private::Address {
            &self.address
        }
        /// Sets the address.
        #[inline]
        pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
            self.address = address;
        }
        /// Sets the address and returns `self`.
        pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
            self.set_address(address);
            self
        }
        /// Returns a reference to the provider.
        #[inline]
        pub const fn provider(&self) -> &P {
            &self.provider
        }
    }
    impl<T, P: ::core::clone::Clone, N> MyStateMachineInstance<T, &P, N> {
        /// Clones the provider and returns a new instance with the cloned provider.
        #[inline]
        pub fn with_cloned_provider(self) -> MyStateMachineInstance<T, P, N> {
            MyStateMachineInstance {
                address: self.address,
                provider: ::core::clone::Clone::clone(&self.provider),
                _network_transport: ::core::marker::PhantomData,
            }
        }
    }
    /// Function calls.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > MyStateMachineInstance<T, P, N> {
        /// Creates a new call builder using this contract instance's provider and address.
        ///
        /// Note that the call can be any function call, not just those defined in this
        /// contract. Prefer using the other methods for building type-safe contract calls.
        pub fn call_builder<C: alloy_sol_types::SolCall>(
            &self,
            call: &C,
        ) -> alloy_contract::SolCallBuilder<T, &P, C, N> {
            alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
        }
        ///Creates a new call builder for the [`context`] function.
        pub fn context(&self) -> alloy_contract::SolCallBuilder<T, &P, contextCall, N> {
            self.call_builder(&contextCall {})
        }
        ///Creates a new call builder for the [`latestBlocks`] function.
        pub fn latestBlocks(
            &self,
            _0: alloy::sol_types::private::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, latestBlocksCall, N> {
            self.call_builder(&latestBlocksCall { _0 })
        }
        ///Creates a new call builder for the [`sequence`] function.
        pub fn sequence(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, sequenceCall, N> {
            self.call_builder(&sequenceCall {})
        }
        ///Creates a new call builder for the [`signal`] function.
        pub fn signal(
            &self,
            action: u8,
            scalar: alloy::sol_types::private::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, signalCall, N> {
            self.call_builder(&signalCall { action, scalar })
        }
        ///Creates a new call builder for the [`signalMany`] function.
        pub fn signalMany(
            &self,
            actions: alloy::sol_types::private::Vec<u8>,
            scalars: alloy::sol_types::private::Vec<alloy::sol_types::private::U256>,
        ) -> alloy_contract::SolCallBuilder<T, &P, signalManyCall, N> {
            self.call_builder(&signalManyCall { actions, scalars })
        }
        ///Creates a new call builder for the [`state`] function.
        pub fn state(
            &self,
            _0: alloy::sol_types::private::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, stateCall, N> {
            self.call_builder(&stateCall { _0 })
        }
    }
    /// Event filters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > MyStateMachineInstance<T, P, N> {
        /// Creates a new event filter using this contract instance's provider and address.
        ///
        /// Note that the type can be any event, not just those defined in this contract.
        /// Prefer using the other methods for building type-safe event filters.
        pub fn event_filter<E: alloy_sol_types::SolEvent>(
            &self,
        ) -> alloy_contract::Event<T, &P, E, N> {
            alloy_contract::Event::new_sol(&self.provider, &self.address)
        }
        ///Creates a new event filter for the [`SignaledEvent`] event.
        pub fn SignaledEvent_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, SignaledEvent, N> {
            self.event_filter::<SignaledEvent>()
        }
    }
}
